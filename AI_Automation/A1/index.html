<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MoodTune - Artistic Emotion-Based Music Player</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sentiment/5.0.2/sentiment.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Poppins", sans-serif;
      }

      body {
        background: linear-gradient(
          135deg,
          #0a0a15 0%,
          #1a1a2e 50%,
          #16213e 100%
        );
        color: #fff;
        min-height: 100vh;
        overflow-x: hidden;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
      }

      header {
        text-align: center;
        padding: 30px 0;
        z-index: 10;
        position: relative;
      }

      h1 {
        font-size: 4rem;
        background: linear-gradient(45deg, #e94584, #0ff0fc, #ffd700, #ff6b6b);
        background-size: 400% 400%;
        background-clip: text;
        -webkit-background-clip: text;
        color: transparent;
        -webkit-text-fill-color: transparent;
        margin-bottom: 15px;
        text-shadow: 0 0 30px rgba(233, 69, 132, 0.5);
        animation: gradientShift 4s ease-in-out infinite;
        letter-spacing: 2px;
      }

      @keyframes gradientShift {
        0%,
        100% {
          background-position: 0% 50%;
        }
        50% {
          background-position: 100% 50%;
        }
      }

      .tagline {
        font-size: 1.4rem;
        color: #a1a8c9;
        margin-bottom: 40px;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      }

      .main-content {
        display: flex;
        flex: 1;
        gap: 40px;
        z-index: 10;
        margin-bottom: 30px;
      }

      .mood-selector {
        flex: 1;
        background: rgba(255, 255, 255, 0.08);
        border-radius: 25px;
        padding: 30px;
        backdrop-filter: blur(15px);
        box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
        max-height: 650px;
      }

      .visualization {
        flex: 2.5;
        border-radius: 25px;
        overflow: hidden;
        position: relative;
        box-shadow: 0 15px 60px rgba(0, 0, 0, 0.4);
        min-height: 600px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .section-title {
        font-size: 1.6rem;
        margin-bottom: 25px;
        color: #6e88ff;
        text-align: center;
        text-shadow: 0 2px 10px rgba(110, 136, 255, 0.3);
      }

      .mood-buttons {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 18px;
        margin-bottom: 35px;
      }

      .mood-btn {
        padding: 18px;
        border: none;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.12);
        color: #fff;
        font-size: 1.1rem;
        cursor: pointer;
        transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        position: relative;
        overflow: hidden;
      }

      .mood-btn::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.2),
          transparent
        );
        transition: left 0.6s;
      }

      .mood-btn:hover::before {
        left: 100%;
      }

      .mood-btn:hover {
        transform: translateY(-5px) scale(1.05);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
      }

      .mood-btn.active {
        transform: translateY(-5px) scale(1.05);
        box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5);
        border: 2px solid rgba(255, 255, 255, 0.4);
      }

      .mood-btn.happy {
        background: linear-gradient(135deg, #ff9a9e, #fad0c4, #ffd89b);
        color: #333;
        box-shadow: 0 8px 25px rgba(255, 154, 158, 0.4);
      }
      .mood-btn.sad {
        background: linear-gradient(135deg, #4facfe, #00f2fe, #667eea);
        box-shadow: 0 8px 25px rgba(79, 172, 254, 0.4);
      }
      .mood-btn.calm {
        background: linear-gradient(135deg, #6a11cb, #2575fc, #43cea2);
        box-shadow: 0 8px 25px rgba(106, 17, 203, 0.4);
      }
      .mood-btn.energetic {
        background: linear-gradient(135deg, #f83600, #f9d423, #ff6b6b);
        color: #333;
        box-shadow: 0 8px 25px rgba(248, 54, 0, 0.4);
      }
      .mood-btn.romantic {
        background: linear-gradient(135deg, #ff057c, #8d0b93, #e94584);
        box-shadow: 0 8px 25px rgba(255, 5, 124, 0.4);
      }
      .mood-btn.focused {
        background: linear-gradient(135deg, #0ba360, #3cba92, #20bf6b);
        box-shadow: 0 8px 25px rgba(11, 163, 96, 0.4);
      }

      .text-input {
        margin-top: 30px;
      }

      textarea {
        width: 100%;
        height: 130px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 16px;
        padding: 18px;
        color: #fff;
        font-size: 1rem;
        margin-bottom: 18px;
        resize: none;
        transition: all 0.3s ease;
      }

      textarea::placeholder {
        color: #a1a8c9;
      }

      textarea:focus {
        outline: none;
        border: 2px solid #6e88ff;
        box-shadow: 0 0 20px rgba(110, 136, 255, 0.3);
        background: rgba(255, 255, 255, 0.12);
      }

      .analyze-btn {
        width: 100%;
        padding: 18px;
        border: none;
        border-radius: 16px;
        background: linear-gradient(135deg, #ff6b6b, #ff8e53, #ffa726);
        color: white;
        font-size: 1.1rem;
        cursor: pointer;
        transition: all 0.4s ease;
        box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);
        position: relative;
        overflow: hidden;
      }

      .analyze-btn::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.3),
          transparent
        );
        transition: left 0.6s;
      }

      .analyze-btn:hover::before {
        left: 100%;
      }

      .analyze-btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 12px 35px rgba(255, 107, 107, 0.5);
      }

      .player-controls {
        background: rgba(255, 255, 255, 0.08);
        border-radius: 25px;
        padding: 30px;
        margin-top: 30px;
        backdrop-filter: blur(15px);
        box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
        z-index: 10;
      }

      .song-info {
        display: flex;
        align-items: center;
        gap: 20px;
        margin-bottom: 25px;
      }

      .album-art {
        width: 90px;
        height: 90px;
        border-radius: 16px;
        background: linear-gradient(135deg, #8e2de2, #4a00e0);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2.2rem;
        box-shadow: 0 8px 25px rgba(142, 45, 226, 0.4);
        animation: pulse 2s ease-in-out infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      .song-details {
        flex: 1;
      }

      .song-title {
        font-size: 1.3rem;
        margin-bottom: 8px;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      }

      .mood-indicator {
        font-size: 1rem;
        color: #a1a8c9;
      }

      .progress-container {
        width: 100%;
        height: 8px;
        background: rgba(255, 255, 255, 0.12);
        border-radius: 4px;
        margin: 20px 0;
        cursor: pointer;
        position: relative;
        overflow: hidden;
      }

      .progress-bar {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #6e88ff, #ff6b6b, #ffd700);
        border-radius: 4px;
        transition: width 0.1s linear;
        box-shadow: 0 0 10px rgba(110, 136, 255, 0.5);
      }

      .controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 25px;
      }

      .control-btn {
        background: none;
        border: none;
        color: #fff;
        font-size: 1.6rem;
        cursor: pointer;
        padding: 12px;
        transition: all 0.3s ease;
        border-radius: 50%;
      }

      .control-btn:hover {
        color: #6e88ff;
        transform: scale(1.2);
        background: rgba(110, 136, 255, 0.2);
      }

      .play-btn {
        background: linear-gradient(135deg, #6e88ff, #ff6b6b);
        width: 70px;
        height: 70px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2rem;
        box-shadow: 0 8px 30px rgba(110, 136, 255, 0.5);
        transition: all 0.3s ease;
      }

      .play-btn:hover {
        transform: scale(1.1);
        box-shadow: 0 12px 40px rgba(110, 136, 255, 0.6);
      }

      .visual-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      .mood-display {
        position: absolute;
        bottom: 25px;
        right: 25px;
        background: rgba(0, 0, 0, 0.6);
        padding: 15px 25px;
        border-radius: 25px;
        font-size: 1.3rem;
        z-index: 11;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .fullscreen-btn {
        position: absolute;
        bottom: 25px;
        left: 25px;
        background: rgba(0, 0, 0, 0.6);
        border: none;
        color: #fff;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        font-size: 1.4rem;
        cursor: pointer;
        transition: all 0.3s ease;
        z-index: 11;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .fullscreen-btn:hover {
        background: rgba(110, 136, 255, 0.8);
        transform: scale(1.1);
        box-shadow: 0 8px 25px rgba(110, 136, 255, 0.5);
      }

      .fullscreen-btn:active {
        transform: scale(0.95);
      }

      /* Fullscreen styles */
      .visualization.fullscreen {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        z-index: 9999 !important;
        border-radius: 0 !important;
      }

      .visualization.fullscreen .mood-display {
        bottom: 40px;
        right: 40px;
        font-size: 1.5rem;
      }

      .visualization.fullscreen .fullscreen-btn {
        bottom: 40px;
        left: 40px;
        width: 70px;
        height: 70px;
        font-size: 1.6rem;
      }

      .mood-text {
        color: #ff6b6b;
        font-weight: bold;
        text-shadow: 0 2px 10px rgba(255, 107, 107, 0.5);
      }

      footer {
        text-align: center;
        padding: 30px 0;
        color: #a1a8c9;
        font-size: 1rem;
        z-index: 10;
      }

      @media (max-width: 1000px) {
        .main-content {
          flex-direction: column;
        }

        h1 {
          font-size: 3rem;
        }

        .container {
          padding: 15px;
        }
      }

      /* Loading animation */
      .loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #6e88ff;
        font-size: 1.2rem;
        z-index: 12;
      }

      .spinner {
        width: 40px;
        height: 40px;
        margin: 0 auto 20px;
        border: 3px solid rgba(110, 136, 255, 0.3);
        border-top: 3px solid #6e88ff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>MoodTune</h1>
        <p class="tagline">Your artistic emotion-based music experience</p>
      </header>

      <div class="main-content">
        <div class="mood-selector">
          <h2 class="section-title">Select Your Mood</h2>
          <div class="mood-buttons">
            <button class="mood-btn happy" data-mood="happy">😊 Happy</button>
            <button class="mood-btn sad" data-mood="sad">😢 Sad</button>
            <button class="mood-btn calm" data-mood="calm">😌 Calm</button>
            <button class="mood-btn energetic" data-mood="energetic">
              ⚡ Energetic
            </button>
            <button class="mood-btn romantic" data-mood="romantic">
              ❤️ Romantic
            </button>
            <button class="mood-btn focused" data-mood="focused">
              🎯 Focused
            </button>
          </div>

          <div class="text-input">
            <h2 class="section-title">Or Describe Your Mood</h2>
            <textarea
              id="mood-text"
              placeholder="Type how you're feeling today..."
            ></textarea>
            <button class="analyze-btn" id="analyze-btn">
              Analyze My Text
            </button>
          </div>
        </div>

        <div class="visualization" id="visualization-container">
          <canvas id="visual-canvas" class="visual-canvas"></canvas>
          <div class="mood-display">
            Current Mood:
            <span class="mood-text" id="current-mood-display">None</span>
          </div>
          <button
            class="fullscreen-btn"
            id="fullscreen-btn"
            title="Toggle Fullscreen"
          >
            ⛶
          </button>
        </div>
      </div>

      <div class="player-controls">
        <div class="song-info">
          <div class="album-art">🎵</div>
          <div class="song-details">
            <div class="song-title" id="song-title">
              Select a mood to start playing
            </div>
            <div class="mood-indicator" id="mood-indicator">Mood: None</div>
          </div>
        </div>

        <div class="progress-container">
          <div class="progress-bar" id="progress-bar"></div>
        </div>

        <div class="controls">
          <button class="control-btn">🔁</button>
          <button class="control-btn">⏮</button>
          <button class="play-btn control-btn" id="play-btn">▶</button>
          <button class="control-btn">⏭</button>
          <button class="control-btn">🔀</button>
        </div>
      </div>

      <footer>
        <p>MoodTune © JinhuiLiang | Artistic Emotion-Based Music Player</p>
      </footer>
    </div>

    <script>
      // Global variables
      let currentMood = null;
      let isPlaying = false;
      let progressInterval;
      let currentAudio = null;
      let audioContext = null;
      let isFullscreen = false;

      // Canvas variables
      let canvas, ctx;
      let animationFrame;
      let time = 0;
      let particles = [];
      let moodElements = [];

      // Romantic mood specific intervals
      let romanticParticleInterval;
      let romanticHeartInterval;

      // Mood to music mapping (unchanged)
      const moodMusic = {
        happy: {
          title: "Upbeat Pop - 'Sunshine Day'",
          color: [255, 223, 100],
          energy: 0.8,
          audioFile: "/AI_Automation/A1/audio/happy.mp3",
        },
        sad: {
          title: "Melancholic Melodies - 'Rainy Nights'",
          color: [100, 150, 255],
          energy: 0.3,
          audioFile: "/AI_Automation/A1/audio/sad.mp3",
        },
        calm: {
          title: "Ambient Relaxation - 'Tranquil Waters'",
          color: [100, 220, 200],
          energy: 0.4,
          audioFile: "/AI_Automation/A1/audio/calm.mp3",
        },
        energetic: {
          title: "High Energy Dance - 'Electric Pulse'",
          color: [255, 100, 100],
          energy: 0.9,
          audioFile: "/AI_Automation/A1/audio/energetic.mp3",
        },
        romantic: {
          title: "Romantic Instrumentals - 'Hearts Entwined'",
          color: [255, 100, 200],
          energy: 0.6,
          audioFile: "/AI_Automation/A1/audio/romantic.mp3",
        },
        focused: {
          title: "Deep Focus - 'Concentration Zone'",
          color: [150, 200, 255],
          energy: 0.5,
          audioFile: "/AI_Automation/A1/audio/focused.mp3",
        },
      };

      // Helper function to convert HSL to RGBA
      function hslToRgba(hslColor) {
        // Extract h, s, l values from HSL string like "hsl(320, 70%, 65%)"
        const hslMatch = hslColor.match(
          /hsl\((\d+(?:\.\d+)?),\s*(\d+(?:\.\d+)?)%?,\s*(\d+(?:\.\d+)?)%?\)/
        );
        if (!hslMatch) {
          // Fallback to pink if parsing fails
          return { r: 255, g: 100, b: 200 };
        }

        const h = parseFloat(hslMatch[1]) / 360;
        const s = parseFloat(hslMatch[2]) / 100;
        const l = parseFloat(hslMatch[3]) / 100;

        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        };

        let r, g, b;
        if (s === 0) {
          r = g = b = l; // achromatic
        } else {
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hue2rgb(p, q, h + 1 / 3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1 / 3);
        }

        return {
          r: Math.round(r * 255),
          g: Math.round(g * 255),
          b: Math.round(b * 255),
        };
      }

      // Helper function to convert HSL to HSLA
      function hslToHsla(hslColor, alpha) {
        return hslColor.replace("hsl(", "hsla(").replace(")", `, ${alpha})`);
      }

      // Helper function to adjust color alpha
      function adjustColorAlpha(colorStr, alpha) {
        if (colorStr.startsWith("hsl(")) {
          return hslToHsla(colorStr, alpha);
        } else if (colorStr.startsWith("rgb(")) {
          return colorStr.replace("rgb(", "rgba(").replace(")", `, ${alpha})`);
        } else if (colorStr.startsWith("rgba(")) {
          // Replace existing alpha
          return colorStr.replace(
            /rgba\(([^,]+,[^,]+,[^,]+),([^)]+)\)/,
            `rgba($1,${alpha})`
          );
        }
        return colorStr; // fallback for other color formats
      }

      // Particle and element classes
      class Particle {
        constructor(x, y, vx, vy, color, size, life, type = "normal") {
          this.x = x;
          this.y = y;
          this.vx = vx;
          this.vy = vy;
          this.color = color;
          this.size = size;
          this.life = life;
          this.maxLife = life;
          this.type = type;
          this.alpha = 1;
          this.rotation = 0;
          this.rotationSpeed = (Math.random() - 0.5) * 0.1;
        }

        update() {
          this.x += this.vx;
          this.y += this.vy;
          this.life--;
          this.alpha = this.life / this.maxLife;
          this.rotation += this.rotationSpeed;

          // Add slight wind effect for romantic petals
          if (this.type === "leaf" || this.type === "heart") {
            this.vx += Math.sin(time * 0.01 + this.x * 0.01) * 0.1;
          }
        }

        draw() {
          if (this.life <= 0) return;

          ctx.save();
          ctx.globalAlpha = this.alpha;
          ctx.translate(this.x, this.y);
          ctx.rotate(this.rotation);
          ctx.fillStyle = this.color;

          switch (this.type) {
            case "bubble":
              this.drawBubble();
              break;
            case "star":
              this.drawStar();
              break;
            case "heart":
              this.drawHeart();
              break;
            case "leaf":
              this.drawLeaf();
              break;
            default:
              ctx.beginPath();
              ctx.arc(0, 0, this.size, 0, Math.PI * 2);
              ctx.fill();
          }

          ctx.restore();
        }

        drawBubble() {
          const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
          gradient.addColorStop(0, adjustColorAlpha(this.color, 1));
          gradient.addColorStop(0.7, adjustColorAlpha(this.color, 0.5));
          gradient.addColorStop(1, adjustColorAlpha(this.color, 0.125));

          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(0, 0, this.size, 0, Math.PI * 2);
          ctx.fill();

          // Highlight
          ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
          ctx.beginPath();
          ctx.arc(
            -this.size * 0.3,
            -this.size * 0.3,
            this.size * 0.3,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }

        drawStar() {
          ctx.fillStyle = this.color;
          const spikes = 5;
          const outerRadius = this.size;
          const innerRadius = this.size * 0.4;

          ctx.beginPath();
          for (let i = 0; i < spikes * 2; i++) {
            const angle = (i / (spikes * 2)) * Math.PI * 2;
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;

            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.fill();
        }

        drawHeart() {
          ctx.fillStyle = this.color;
          const size = this.size;

          ctx.beginPath();
          ctx.moveTo(0, size * 0.3);
          ctx.bezierCurveTo(0, 0, -size * 0.5, 0, -size * 0.5, size * 0.3);
          ctx.bezierCurveTo(-size * 0.5, size * 0.6, 0, size, 0, size);
          ctx.bezierCurveTo(
            0,
            size,
            size * 0.5,
            size * 0.6,
            size * 0.5,
            size * 0.3
          );
          ctx.bezierCurveTo(size * 0.5, 0, 0, 0, 0, size * 0.3);
          ctx.closePath();
          ctx.fill();

          // Add a subtle glow effect
          ctx.shadowBlur = 10;
          ctx.shadowColor = this.color;
          ctx.fill();
        }

        drawLeaf() {
          const gradient = ctx.createLinearGradient(
            0,
            -this.size,
            0,
            this.size
          );
          gradient.addColorStop(0, adjustColorAlpha(this.color, 1));
          gradient.addColorStop(0.5, adjustColorAlpha(this.color, 0.67));
          gradient.addColorStop(1, adjustColorAlpha(this.color, 0.4));

          ctx.fillStyle = gradient;
          const size = this.size;

          ctx.beginPath();
          ctx.moveTo(0, -size);
          ctx.quadraticCurveTo(size * 0.6, -size * 0.2, 0, size);
          ctx.quadraticCurveTo(-size * 0.6, -size * 0.2, 0, -size);
          ctx.closePath();
          ctx.fill();
        }
      }

      // Clear romantic intervals function
      function clearRomanticIntervals() {
        if (romanticParticleInterval) {
          clearInterval(romanticParticleInterval);
          romanticParticleInterval = null;
        }
        if (romanticHeartInterval) {
          clearInterval(romanticHeartInterval);
          romanticHeartInterval = null;
        }
      }

      // Artistic mood animations
      function createHappyAnimation() {
        particles = [];
        moodElements = [];

        // Create flowing rainbow streams
        for (let i = 0; i < 8; i++) {
          moodElements.push({
            type: "rainbow_stream",
            x: Math.random() * canvas.width,
            y: -50,
            wave: i * 0.5,
            speed: 2 + Math.random() * 3,
            width: 20 + Math.random() * 30,
            colors: [
              `hsl(${60 + i * 30}, 80%, 70%)`,
              `hsl(${90 + i * 30}, 80%, 70%)`,
              `hsl(${120 + i * 30}, 80%, 70%)`,
            ],
          });
        }

        // Sparkling joy particles
        setInterval(() => {
          if (currentMood !== "happy") return;
          for (let i = 0; i < 5; i++) {
            particles.push(
              new Particle(
                Math.random() * canvas.width,
                Math.random() * canvas.height,
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2,
                `hsl(${Math.random() * 60 + 30}, 90%, 70%)`,
                3 + Math.random() * 8,
                60 + Math.random() * 60,
                "star"
              )
            );
          }
        }, 100);
      }

      function createSadAnimation() {
        particles = [];
        moodElements = [];

        // Create melancholic water drops
        moodElements.push({
          type: "rain_system",
          drops: [],
        });

        // Misty atmosphere
        for (let i = 0; i < 15; i++) {
          moodElements.push({
            type: "mist_cloud",
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: 50 + Math.random() * 100,
            drift: Math.random() * 0.5,
            opacity: 0.1 + Math.random() * 0.3,
          });
        }

        // Gentle tears
        setInterval(() => {
          if (currentMood !== "sad") return;
          particles.push(
            new Particle(
              Math.random() * canvas.width,
              -10,
              Math.sin(time * 0.01) * 0.5,
              2 + Math.random() * 3,
              `rgba(100, 150, 255, ${0.6 + Math.random() * 0.4})`,
              2 + Math.random() * 4,
              200 + Math.random() * 100
            )
          );
        }, 150);
      }

      function createCalmAnimation() {
        particles = [];
        moodElements = [];

        // Zen garden ripples
        moodElements.push({
          type: "zen_garden",
          ripples: [],
        });

        // Floating meditation orbs
        for (let i = 0; i < 12; i++) {
          moodElements.push({
            type: "meditation_orb",
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            baseY: Math.random() * canvas.height,
            size: 15 + Math.random() * 25,
            phase: Math.random() * Math.PI * 2,
            color: `hsl(${180 + Math.random() * 60}, 60%, 65%)`,
          });
        }

        // Gentle breathing particles
        setInterval(() => {
          if (currentMood !== "calm") return;
          particles.push(
            new Particle(
              canvas.width / 2 + (Math.random() - 0.5) * 200,
              canvas.height / 2 + (Math.random() - 0.5) * 200,
              (Math.random() - 0.5) * 0.5,
              (Math.random() - 0.5) * 0.5,
              `hsla(${180 + Math.random() * 60}, 70%, 70%, 0.6)`,
              8 + Math.random() * 12,
              120 + Math.random() * 80,
              "bubble"
            )
          );
        }, 300);
      }

      function createEnergeticAnimation() {
        particles = [];
        moodElements = [];

        // Electric energy streams
        for (let i = 0; i < 6; i++) {
          moodElements.push({
            type: "energy_bolt",
            points: [],
            life: 30 + Math.random() * 20,
            color: `hsl(${Math.random() * 60 + 300}, 90%, 70%)`,
            width: 3 + Math.random() * 5,
          });
        }

        // Pulsing energy core
        moodElements.push({
          type: "energy_core",
          x: canvas.width / 2,
          y: canvas.height / 2,
          size: 50,
          pulsePhase: 0,
        });

        // High-energy particles
        setInterval(() => {
          if (currentMood !== "energetic") return;
          for (let i = 0; i < 8; i++) {
            const angle = ((Math.PI * 2) / 8) * i + time * 0.02;
            particles.push(
              new Particle(
                canvas.width / 2 + Math.cos(angle) * 100,
                canvas.height / 2 + Math.sin(angle) * 100,
                Math.cos(angle) * 5,
                Math.sin(angle) * 5,
                `hsl(${Math.random() * 60 + 15}, 100%, 60%)`,
                4 + Math.random() * 6,
                40 + Math.random() * 30,
                "star"
              )
            );
          }
        }, 80);
      }

      function createRomanticAnimation() {
        // Clear any existing romantic intervals first
        clearRomanticIntervals();

        particles = [];
        moodElements = [];

        // Romantic atmosphere with soft glows
        for (let i = 0; i < 20; i++) {
          moodElements.push({
            type: "romantic_glow",
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: 30 + Math.random() * 60,
            pulse: Math.random() * Math.PI * 2,
            color: `hsl(${320 + Math.random() * 40}, 70%, 65%)`,
          });
        }

        // Rose petals falling - using interval stored in global variable
        romanticParticleInterval = setInterval(() => {
          if (currentMood !== "romantic") {
            clearRomanticIntervals();
            return;
          }

          // Create multiple petals at once for better visual effect
          for (let i = 0; i < 2; i++) {
            particles.push(
              new Particle(
                Math.random() * canvas.width,
                -20,
                (Math.random() - 0.5) * 2,
                1 + Math.random() * 2,
                `hsl(${340 + Math.random() * 40}, 80%, 70%)`,
                6 + Math.random() * 8,
                300 + Math.random() * 200,
                "leaf"
              )
            );
          }
        }, 150); // More frequent generation

        // Floating hearts - using interval stored in global variable
        romanticHeartInterval = setInterval(() => {
          if (currentMood !== "romantic") {
            clearRomanticIntervals();
            return;
          }

          particles.push(
            new Particle(
              Math.random() * canvas.width,
              canvas.height + 20,
              (Math.random() - 0.5) * 1,
              -1 - Math.random() * 2,
              `hsl(${340 + Math.random() * 20}, 90%, 75%)`,
              8 + Math.random() * 12,
              250 + Math.random() * 150,
              "heart"
            )
          );
        }, 300);
      }

      function createFocusedAnimation() {
        particles = [];
        moodElements = [];

        // Neural network visualization
        moodElements.push({
          type: "neural_network",
          nodes: [],
          connections: [],
        });

        // Initialize neural network
        const network = moodElements[0];
        for (let i = 0; i < 25; i++) {
          network.nodes.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: 4 + Math.random() * 8,
            pulse: Math.random() * Math.PI * 2,
            connections: [],
          });
        }

        // Create connections
        network.nodes.forEach((node, i) => {
          for (let j = i + 1; j < network.nodes.length; j++) {
            const other = network.nodes[j];
            const dist = Math.hypot(node.x - other.x, node.y - other.y);
            if (dist < 150) {
              network.connections.push({
                from: node,
                to: other,
                strength: 1 - dist / 150,
                pulse: Math.random() * Math.PI * 2,
              });
            }
          }
        });

        // Data flow particles
        setInterval(() => {
          if (currentMood !== "focused") return;
          const connection =
            network.connections[
              Math.floor(Math.random() * network.connections.length)
            ];
          if (connection) {
            particles.push(
              new Particle(
                connection.from.x,
                connection.from.y,
                (connection.to.x - connection.from.x) / 50,
                (connection.to.y - connection.from.y) / 50,
                `hsl(${200 + Math.random() * 40}, 80%, 70%)`,
                3 + Math.random() * 4,
                50,
                "normal"
              )
            );
          }
        }, 100);
      }

      // Canvas initialization
      function initCanvas() {
        canvas = document.getElementById("visual-canvas");
        ctx = canvas.getContext("2d");
        resizeCanvas();
        animate();
      }

      function resizeCanvas() {
        const container = document.getElementById("visualization-container");
        const rect = container.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
      }

      // Main animation loop
      function animate() {
        animationFrame = requestAnimationFrame(animate);
        time++;

        // Clear canvas with fade effect
        ctx.fillStyle = "rgba(10, 10, 21, 0.1)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (currentMood) {
          updateMoodAnimation();
        } else {
          drawDefaultVisualization();
        }

        updateParticles();
      }

      function updateMoodAnimation() {
        switch (currentMood) {
          case "happy":
            updateHappyAnimation();
            break;
          case "sad":
            updateSadAnimation();
            break;
          case "calm":
            updateCalmAnimation();
            break;
          case "energetic":
            updateEnergeticAnimation();
            break;
          case "romantic":
            updateRomanticAnimation();
            break;
          case "focused":
            updateFocusedAnimation();
            break;
        }
      }

      function updateHappyAnimation() {
        moodElements.forEach((element) => {
          if (element.type === "rainbow_stream") {
            element.y += element.speed;
            if (element.y > canvas.height + 50) {
              element.y = -50;
              element.x = Math.random() * canvas.width;
            }

            // Draw flowing rainbow stream
            ctx.save();
            const gradient = ctx.createLinearGradient(
              0,
              element.y - 50,
              0,
              element.y + 50
            );
            element.colors.forEach((color, i) => {
              gradient.addColorStop(i / (element.colors.length - 1), color);
            });

            ctx.strokeStyle = gradient;
            ctx.lineWidth = element.width;
            ctx.lineCap = "round";

            ctx.beginPath();
            for (let i = 0; i < 100; i++) {
              const x = element.x + Math.sin(element.wave + i * 0.1) * 50;
              const y = element.y + i * 2;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.restore();
          }
        });
      }

      function updateSadAnimation() {
        moodElements.forEach((element) => {
          if (element.type === "mist_cloud") {
            element.x += element.drift;
            if (element.x > canvas.width + element.size) {
              element.x = -element.size;
            }

            // Draw misty clouds
            ctx.save();
            ctx.globalAlpha = element.opacity;
            const gradient = ctx.createRadialGradient(
              element.x,
              element.y,
              element.size * 0.5,
              element.x,
              element.y,
              element.size
            );
            gradient.addColorStop(0, "rgba(100, 120, 180, 0.3)");
            gradient.addColorStop(1, "rgba(100, 120, 180, 0)");

            ctx.fillStyle = gradient;
            ctx.fillRect(
              element.x - element.size,
              element.y - element.size,
              element.size * 2,
              element.size * 2
            );
            ctx.restore();
          }
        });
      }

      function updateCalmAnimation() {
        moodElements.forEach((element) => {
          if (element.type === "meditation_orb") {
            element.y =
              element.baseY + Math.sin(time * 0.01 + element.phase) * 20;

            // Draw meditation orb with soft glow
            ctx.save();
            const gradient = ctx.createRadialGradient(
              element.x,
              element.y,
              0,
              element.x,
              element.y,
              element.size * 2
            );
            gradient.addColorStop(0, adjustColorAlpha(element.color, 0.8));
            gradient.addColorStop(0.5, adjustColorAlpha(element.color, 0.4));
            gradient.addColorStop(1, adjustColorAlpha(element.color, 0));

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(element.x, element.y, element.size * 2, 0, Math.PI * 2);
            ctx.fill();

            // Inner orb
            ctx.fillStyle = adjustColorAlpha(element.color, 0.8);
            ctx.beginPath();
            ctx.arc(element.x, element.y, element.size * 0.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          } else if (element.type === "zen_garden") {
            // Create ripples occasionally
            if (Math.random() < 0.02) {
              element.ripples.push({
                x: Math.random() * canvas.width,
                y: canvas.height * 0.7 + Math.random() * canvas.height * 0.3,
                radius: 0,
                maxRadius: 80 + Math.random() * 100,
                life: 180,
              });
            }

            // Update and draw ripples
            element.ripples = element.ripples.filter((ripple) => {
              ripple.radius += ripple.maxRadius / ripple.life;
              ripple.life--;

              if (ripple.life > 0) {
                ctx.save();
                ctx.globalAlpha = ripple.life / 180;
                ctx.strokeStyle = "rgba(100, 220, 200, 0.6)";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
                return true;
              }
              return false;
            });
          }
        });
      }

      function updateEnergeticAnimation() {
        moodElements.forEach((element) => {
          if (element.type === "energy_bolt") {
            element.life--;
            if (element.life <= 0 || element.points.length === 0) {
              // Generate new lightning bolt
              element.points = [];
              element.life = 30 + Math.random() * 20;

              const startX = Math.random() * canvas.width;
              const startY = Math.random() * canvas.height * 0.3;
              const endX = Math.random() * canvas.width;
              const endY =
                canvas.height * 0.7 + Math.random() * canvas.height * 0.3;

              // Create jagged path
              const segments = 8 + Math.random() * 8;
              for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const x =
                  startX + (endX - startX) * t + (Math.random() - 0.5) * 50;
                const y =
                  startY + (endY - startY) * t + (Math.random() - 0.5) * 30;
                element.points.push({ x, y });
              }
            }

            // Draw lightning bolt
            if (element.points.length > 1) {
              ctx.save();
              ctx.globalAlpha = Math.random() > 0.3 ? 0.8 : 0.3; // Flickering effect
              ctx.strokeStyle = element.color;
              ctx.lineWidth = element.width;
              ctx.lineCap = "round";
              ctx.lineJoin = "round";

              ctx.beginPath();
              element.points.forEach((point, i) => {
                if (i === 0) ctx.moveTo(point.x, point.y);
                else ctx.lineTo(point.x, point.y);
              });
              ctx.stroke();

              // Glow effect
              ctx.shadowBlur = 20;
              ctx.shadowColor = element.color;
              ctx.stroke();
              ctx.restore();
            }
          } else if (element.type === "energy_core") {
            element.pulsePhase += 0.1;
            const pulseSize = element.size + Math.sin(element.pulsePhase) * 20;

            // Draw pulsing energy core
            ctx.save();
            const gradient = ctx.createRadialGradient(
              element.x,
              element.y,
              0,
              element.x,
              element.y,
              pulseSize
            );
            gradient.addColorStop(0, "rgba(255, 100, 100, 0.8)");
            gradient.addColorStop(0.5, "rgba(255, 200, 0, 0.4)");
            gradient.addColorStop(1, "rgba(255, 100, 100, 0)");

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(element.x, element.y, pulseSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        });
      }

      function updateRomanticAnimation() {
        moodElements.forEach((element) => {
          if (element.type === "romantic_glow") {
            element.pulse += 0.03;
            const glowSize = element.size + Math.sin(element.pulse) * 15;

            // Draw romantic glow with enhanced visibility
            ctx.save();
            ctx.globalAlpha = 0.4 + Math.sin(element.pulse) * 0.3;

            // Convert HSL to RGBA for proper alpha blending
            const rgbaColor = hslToRgba(element.color);

            const gradient = ctx.createRadialGradient(
              element.x,
              element.y,
              0,
              element.x,
              element.y,
              glowSize
            );

            gradient.addColorStop(
              0,
              `rgba(${rgbaColor.r}, ${rgbaColor.g}, ${rgbaColor.b}, 0.8)`
            );
            gradient.addColorStop(
              0.5,
              `rgba(${rgbaColor.r}, ${rgbaColor.g}, ${rgbaColor.b}, 0.4)`
            );
            gradient.addColorStop(
              1,
              `rgba(${rgbaColor.r}, ${rgbaColor.g}, ${rgbaColor.b}, 0)`
            );

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(element.x, element.y, glowSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        });
      }

      function updateFocusedAnimation() {
        moodElements.forEach((element) => {
          if (element.type === "neural_network") {
            // Update node pulses
            element.nodes.forEach((node) => {
              node.pulse += 0.05;
            });

            // Draw connections
            ctx.save();
            element.connections.forEach((conn) => {
              conn.pulse += 0.1;
              const alpha = 0.3 + Math.sin(conn.pulse) * 0.2;

              ctx.globalAlpha = alpha * conn.strength;
              ctx.strokeStyle = `hsl(${
                200 + Math.sin(conn.pulse) * 20
              }, 70%, 60%)`;
              ctx.lineWidth = 1 + conn.strength * 2;

              ctx.beginPath();
              ctx.moveTo(conn.from.x, conn.from.y);
              ctx.lineTo(conn.to.x, conn.to.y);
              ctx.stroke();
            });

            // Draw nodes
            element.nodes.forEach((node) => {
              const nodeSize = node.size + Math.sin(node.pulse) * 3;

              ctx.globalAlpha = 0.8;
              ctx.fillStyle = `hsl(${
                220 + Math.sin(node.pulse) * 10
              }, 80%, 70%)`;
              ctx.beginPath();
              ctx.arc(node.x, node.y, nodeSize, 0, Math.PI * 2);
              ctx.fill();

              // Node glow
              ctx.globalAlpha = 0.3;
              ctx.fillStyle = `hsl(${
                220 + Math.sin(node.pulse) * 10
              }, 80%, 70%)`;
              ctx.beginPath();
              ctx.arc(node.x, node.y, nodeSize * 2, 0, Math.PI * 2);
              ctx.fill();
            });
            ctx.restore();
          }
        });
      }

      function updateParticles() {
        particles = particles.filter((particle) => {
          particle.update();
          particle.draw();
          return particle.life > 0;
        });
      }

      function drawDefaultVisualization() {
        // Gentle ambient animation when no mood is selected
        ctx.save();
        ctx.globalAlpha = 0.5;

        for (let i = 0; i < 3; i++) {
          const x = canvas.width / 2 + Math.sin(time * 0.01 + i) * 100;
          const y = canvas.height / 2 + Math.cos(time * 0.015 + i) * 60;
          const size = 30 + Math.sin(time * 0.02 + i) * 15;

          const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
          gradient.addColorStop(0, "rgba(110, 136, 255, 0.6)");
          gradient.addColorStop(1, "rgba(110, 136, 255, 0)");

          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      // Audio functions (unchanged from original)
      function initializeAudio() {
        if (!audioContext) {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
        }
      }

      function loadAudioForMood(mood) {
        const moodData = moodMusic[mood];

        if (currentAudio) {
          currentAudio.pause();
          currentAudio.currentTime = 0;
          currentAudio = null;
        }

        if (moodData.audioFile) {
          try {
            currentAudio = new Audio(moodData.audioFile);
            currentAudio.loop = true;

            currentAudio.addEventListener("loadstart", () => {
              console.log(`Loading audio for ${mood}...`);
            });

            currentAudio.addEventListener("canplaythrough", () => {
              console.log(`Audio for ${mood} is ready to play`);
            });

            currentAudio.addEventListener("error", (e) => {
              console.error(`Error loading audio for ${mood}:`, e);
              showAudioError(mood);
            });

            currentAudio.addEventListener("timeupdate", () => {
              updateProgressBar();
            });

            currentAudio.addEventListener("ended", () => {
              isPlaying = false;
              document.getElementById("play-btn").textContent = "▶";
              document.getElementById("progress-bar").style.width = "0%";
            });
          } catch (error) {
            console.error(`Failed to create audio for ${mood}:`, error);
            showAudioError(mood);
          }
        } else {
          console.log(`No audio file specified for ${mood} mood`);
        }
      }

      function showAudioError(mood) {
        const songTitle = document.getElementById("song-title");
        songTitle.textContent = `${moodMusic[mood].title} (Audio not available)`;
        songTitle.style.color = "#ff6b6b";

        setTimeout(() => {
          songTitle.style.color = "#fff";
        }, 3000);
      }

      function updateProgressBar() {
        if (currentAudio && currentAudio.duration) {
          const progress =
            (currentAudio.currentTime / currentAudio.duration) * 100;
          document.getElementById("progress-bar").style.width = `${progress}%`;
        }
      }

      // Fullscreen functionality
      function toggleFullscreen() {
        const visualizationContainer = document.getElementById(
          "visualization-container"
        );
        const fullscreenBtn = document.getElementById("fullscreen-btn");

        if (!isFullscreen) {
          if (visualizationContainer.requestFullscreen) {
            visualizationContainer.requestFullscreen();
          } else if (visualizationContainer.webkitRequestFullscreen) {
            visualizationContainer.webkitRequestFullscreen();
          } else if (visualizationContainer.mozRequestFullScreen) {
            visualizationContainer.mozRequestFullScreen();
          } else if (visualizationContainer.msRequestFullscreen) {
            visualizationContainer.msRequestFullscreen();
          } else {
            visualizationContainer.classList.add("fullscreen");
            isFullscreen = true;
            fullscreenBtn.innerHTML = "⛷";
            fullscreenBtn.title = "Exit Fullscreen";
            setTimeout(() => resizeCanvas(), 100);
          }
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          } else {
            visualizationContainer.classList.remove("fullscreen");
            isFullscreen = false;
            fullscreenBtn.innerHTML = "⛶";
            fullscreenBtn.title = "Toggle Fullscreen";
            setTimeout(() => resizeCanvas(), 100);
          }
        }
      }

      function handleFullscreenChange() {
        const visualizationContainer = document.getElementById(
          "visualization-container"
        );
        const fullscreenBtn = document.getElementById("fullscreen-btn");

        const isCurrentlyFullscreen = !!(
          document.fullscreenElement ||
          document.webkitFullscreenElement ||
          document.mozFullScreenElement ||
          document.msFullscreenElement
        );

        if (isCurrentlyFullscreen && !isFullscreen) {
          isFullscreen = true;
          visualizationContainer.classList.add("fullscreen");
          fullscreenBtn.innerHTML = "⛷";
          fullscreenBtn.title = "Exit Fullscreen";
          setTimeout(() => resizeCanvas(), 100);
        } else if (!isCurrentlyFullscreen && isFullscreen) {
          isFullscreen = false;
          visualizationContainer.classList.remove("fullscreen");
          fullscreenBtn.innerHTML = "⛶";
          fullscreenBtn.title = "Toggle Fullscreen";
          setTimeout(() => resizeCanvas(), 100);
        }
      }

      // Event handlers
      function setMood(mood) {
        // Clear any existing romantic intervals when changing moods
        clearRomanticIntervals();

        currentMood = mood;
        const moodData = moodMusic[mood];

        document.getElementById("current-mood-display").textContent =
          mood.charAt(0).toUpperCase() + mood.slice(1);
        document.getElementById("song-title").textContent = moodData.title;
        document.getElementById("mood-indicator").textContent = `Mood: ${
          mood.charAt(0).toUpperCase() + mood.slice(1)
        }`;

        const [r, g, b] = moodData.color;
        document.body.style.background = `
          linear-gradient(135deg, 
          rgba(${r}, ${g}, ${b}, 0.15) 0%, 
          #0a0a15 50%,
          #16213e 100%)
        `;

        // Create artistic visualization for mood
        switch (mood) {
          case "happy":
            createHappyAnimation();
            break;
          case "sad":
            createSadAnimation();
            break;
          case "calm":
            createCalmAnimation();
            break;
          case "energetic":
            createEnergeticAnimation();
            break;
          case "romantic":
            createRomanticAnimation();
            break;
          case "focused":
            createFocusedAnimation();
            break;
        }

        loadAudioForMood(mood);

        isPlaying = false;
        document.getElementById("play-btn").textContent = "▶";
        document.getElementById("progress-bar").style.width = "0%";
        clearInterval(progressInterval);

        console.log(`Mood set to: ${mood} with artistic visualization`);
      }

      function analyzeText(text) {
        function performSentimentAnalysis(text) {
          const lowerText = text.toLowerCase();

          const moodKeywords = {
            happy: [
              "happy",
              "joy",
              "excited",
              "great",
              "awesome",
              "fantastic",
              "wonderful",
              "amazing",
              "cheerful",
              "delighted",
              "thrilled",
              "ecstatic",
              "elated",
              "upbeat",
              "positive",
              "good",
              "excellent",
              "brilliant",
              "superb",
              "marvelous",
            ],
            sad: [
              "sad",
              "depressed",
              "down",
              "unhappy",
              "miserable",
              "melancholy",
              "blue",
              "gloomy",
              "sorrowful",
              "dejected",
              "downhearted",
              "disheartened",
              "despondent",
              "mournful",
              "grief",
              "crying",
              "tears",
              "heartbroken",
              "devastated",
            ],
            energetic: [
              "energetic",
              "pumped",
              "hyper",
              "active",
              "dynamic",
              "vigorous",
              "lively",
              "animated",
              "spirited",
              "bouncy",
              "zippy",
              "peppy",
              "enthusiastic",
              "motivated",
              "charged",
              "fired up",
              "ready",
              "go",
            ],
            calm: [
              "calm",
              "peaceful",
              "relaxed",
              "serene",
              "tranquil",
              "quiet",
              "still",
              "zen",
              "meditative",
              "restful",
              "soothing",
              "gentle",
              "mild",
              "soft",
              "placid",
              "composed",
              "balanced",
              "centered",
            ],
            romantic: [
              "love",
              "romance",
              "romantic",
              "heart",
              "valentine",
              "kiss",
              "affection",
              "tender",
              "intimate",
              "passion",
              "adore",
              "cherish",
              "sweetheart",
              "darling",
              "beloved",
              "crush",
              "dating",
              "relationship",
            ],
            focused: [
              "focused",
              "concentrate",
              "work",
              "study",
              "productive",
              "determined",
              "goal",
              "target",
              "organized",
              "disciplined",
              "serious",
              "committed",
              "dedicated",
              "intense",
              "deep",
              "analytical",
              "thinking",
              "planning",
            ],
          };

          const moodScores = {};
          for (const [mood, keywords] of Object.entries(moodKeywords)) {
            moodScores[mood] = 0;
            keywords.forEach((keyword) => {
              if (lowerText.includes(keyword)) {
                moodScores[mood]++;
              }
            });
          }

          let bestMood = "calm";
          let highestScore = 0;
          for (const [mood, score] of Object.entries(moodScores)) {
            if (score > highestScore) {
              highestScore = score;
              bestMood = mood;
            }
          }

          if (highestScore === 0) {
            const positiveWords = [
              "good",
              "nice",
              "ok",
              "okay",
              "fine",
              "well",
              "better",
              "best",
              "great",
              "excellent",
            ];
            const negativeWords = [
              "bad",
              "terrible",
              "awful",
              "horrible",
              "worst",
              "hate",
              "angry",
              "mad",
              "frustrated",
              "annoyed",
            ];

            const positiveCount = positiveWords.filter((word) =>
              lowerText.includes(word)
            ).length;
            const negativeCount = negativeWords.filter((word) =>
              lowerText.includes(word)
            ).length;

            if (positiveCount > negativeCount) {
              bestMood = "happy";
            } else if (negativeCount > positiveCount) {
              bestMood = "sad";
            } else {
              bestMood = "calm";
            }
          }

          return bestMood;
        }

        let mood;

        if (typeof Sentiment !== "undefined") {
          try {
            const sentiment = new Sentiment();
            const result = sentiment.analyze(text);

            if (result.score > 3) {
              mood = "happy";
            } else if (result.score > 1) {
              mood = "energetic";
            } else if (result.score > -1) {
              mood = "calm";
            } else if (result.score > -3) {
              mood = "focused";
            } else {
              mood = "sad";
            }

            const romanticWords = [
              "love",
              "heart",
              "romance",
              "romantic",
              "valentine",
            ];
            if (
              romanticWords.some((word) => text.toLowerCase().includes(word))
            ) {
              mood = "romantic";
            }

            console.log("Using Sentiment.js analysis:", result);
          } catch (error) {
            console.log("Sentiment.js error, using keyword analysis");
            mood = performSentimentAnalysis(text);
          }
        } else {
          console.log("Sentiment.js not available, using keyword analysis");
          mood = performSentimentAnalysis(text);
        }

        console.log(`Analyzed text: "${text}" -> Mood: ${mood}`);
        setMood(mood);

        document
          .querySelectorAll(".mood-btn")
          .forEach((btn) => btn.classList.remove("active"));
        const moodButton = document.querySelector(`[data-mood="${mood}"]`);
        if (moodButton) {
          moodButton.classList.add("active");
        }

        document.getElementById("mood-text").value = "";
      }

      function togglePlayback() {
        initializeAudio();

        if (!currentMood) {
          alert("Please select a mood first!");
          return;
        }

        if (!currentAudio) {
          console.log("No audio file loaded, using simulation mode");
          simulatePlayback();
          return;
        }

        isPlaying = !isPlaying;

        if (isPlaying) {
          document.getElementById("play-btn").textContent = "⏸";

          if (audioContext && audioContext.state === "suspended") {
            audioContext.resume();
          }

          currentAudio
            .play()
            .then(() => {
              console.log(`Playing audio for ${currentMood}`);
            })
            .catch((error) => {
              console.error("Audio playback failed:", error);
              simulatePlayback();
            });
        } else {
          document.getElementById("play-btn").textContent = "▶";

          if (currentAudio) {
            currentAudio.pause();
          }

          clearInterval(progressInterval);
        }
      }

      function simulatePlayback() {
        isPlaying = !isPlaying;

        if (isPlaying) {
          document.getElementById("play-btn").textContent = "⏸";
          console.log(`Simulating playback for ${currentMood} track`);

          clearInterval(progressInterval);
          let progress = 0;
          const progressBar = document.getElementById("progress-bar");

          progressInterval = setInterval(() => {
            if (!isPlaying) {
              clearInterval(progressInterval);
              return;
            }

            progress += 0.5;
            if (progress > 100) progress = 0;
            progressBar.style.width = `${progress}%`;
          }, 100);
        } else {
          document.getElementById("play-btn").textContent = "▶";
          clearInterval(progressInterval);
        }
      }

      // Initialize when DOM is loaded
      document.addEventListener("DOMContentLoaded", function () {
        // Initialize Canvas
        initCanvas();

        // Window resize handler
        window.addEventListener("resize", resizeCanvas);

        document.addEventListener("click", initializeAudio, { once: true });

        document.addEventListener("fullscreenchange", handleFullscreenChange);
        document.addEventListener(
          "webkitfullscreenchange",
          handleFullscreenChange
        );
        document.addEventListener(
          "mozfullscreenchange",
          handleFullscreenChange
        );
        document.addEventListener("MSFullscreenChange", handleFullscreenChange);

        document
          .getElementById("fullscreen-btn")
          .addEventListener("click", (e) => {
            e.stopPropagation();
            toggleFullscreen();
          });

        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape" && isFullscreen) {
            toggleFullscreen();
          }
        });

        document.querySelectorAll(".mood-btn").forEach((button) => {
          button.addEventListener("click", (e) => {
            const mood = button.getAttribute("data-mood");
            setMood(mood);

            document
              .querySelectorAll(".mood-btn")
              .forEach((btn) => btn.classList.remove("active"));
            button.classList.add("active");
          });
        });

        document.getElementById("analyze-btn").addEventListener("click", () => {
          const text = document.getElementById("mood-text").value.trim();
          if (text) {
            analyzeText(text);
          }
        });

        document
          .getElementById("play-btn")
          .addEventListener("click", togglePlayback);

        document
          .querySelector(".progress-container")
          .addEventListener("click", (e) => {
            if (currentAudio && currentAudio.duration) {
              const rect = e.target.getBoundingClientRect();
              const clickPosition = (e.clientX - rect.left) / rect.width;
              const newTime = clickPosition * currentAudio.duration;
              currentAudio.currentTime = newTime;
            }
          });
      });

      // Cleanup function
      function cleanup() {
        if (animationFrame) {
          cancelAnimationFrame(animationFrame);
        }

        if (currentAudio) {
          currentAudio.pause();
          currentAudio = null;
        }

        clearInterval(progressInterval);
        clearRomanticIntervals();

        // Clear particles and elements
        particles = [];
        moodElements = [];
      }

      // Handle page unload
      window.addEventListener("beforeunload", cleanup);
    </script>
  </body>
</html>
