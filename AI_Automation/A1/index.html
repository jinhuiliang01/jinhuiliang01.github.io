<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MoodTune - Emotion-Based Music Player</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sentiment/5.0.2/sentiment.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Poppins", sans-serif;
      }

      body {
        background: linear-gradient(
          135deg,
          #0a0a15 0%,
          #1a1a2e 50%,
          #16213e 100%
        );
        color: #fff;
        min-height: 100vh;
        overflow-x: hidden;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
      }

      header {
        text-align: center;
        padding: 30px 0;
        z-index: 10;
        position: relative;
      }

      h1 {
        font-size: 4rem;
        background: linear-gradient(45deg, #e94584, #0ff0fc, #ffd700, #ff6b6b);
        background-size: 400% 400%;
        background-clip: text;
        -webkit-background-clip: text;
        color: transparent;
        -webkit-text-fill-color: transparent;
        margin-bottom: 15px;
        text-shadow: 0 0 30px rgba(233, 69, 132, 0.5);
        animation: gradientShift 4s ease-in-out infinite;
        letter-spacing: 2px;
      }

      @keyframes gradientShift {
        0%,
        100% {
          background-position: 0% 50%;
        }
        50% {
          background-position: 100% 50%;
        }
      }

      .tagline {
        font-size: 1.4rem;
        color: #a1a8c9;
        margin-bottom: 40px;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      }

      .main-content {
        display: flex;
        flex: 1;
        gap: 40px;
        z-index: 10;
        margin-bottom: 30px;
      }

      .left-panel {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .ai-chat {
        background: rgba(255, 255, 255, 0.08);
        border-radius: 25px;
        padding: 30px;
        backdrop-filter: blur(15px);
        box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
        min-height: 400px;
        display: flex;
        flex-direction: column;
      }

      .mood-selector {
        background: rgba(255, 255, 255, 0.08);
        border-radius: 25px;
        padding: 30px;
        backdrop-filter: blur(15px);
        box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .visualization {
        flex: 2.5;
        border-radius: 25px;
        overflow: hidden;
        position: relative;
        box-shadow: 0 15px 60px rgba(0, 0, 0, 0.4);
        min-height: 600px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .section-title {
        font-size: 1.6rem;
        margin-bottom: 25px;
        color: #6e88ff;
        text-align: center;
        text-shadow: 0 2px 10px rgba(110, 136, 255, 0.3);
      }

      .chat-messages {
        flex: 1;
        overflow-y: auto;
        margin-bottom: 20px;
        padding-right: 10px;
        max-height: 300px;
      }

      .message {
        margin-bottom: 15px;
        padding: 12px 18px;
        border-radius: 16px;
        max-width: 85%;
        animation: fadeInUp 0.3s ease;
      }

      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .message.ai {
        background: linear-gradient(
          135deg,
          rgba(110, 136, 255, 0.2),
          rgba(110, 136, 255, 0.1)
        );
        border-left: 3px solid #6e88ff;
        align-self: flex-start;
      }

      .message.user {
        background: linear-gradient(
          135deg,
          rgba(255, 107, 107, 0.2),
          rgba(255, 107, 107, 0.1)
        );
        border-left: 3px solid #ff6b6b;
        margin-left: auto;
        align-self: flex-end;
      }

      .message-header {
        font-size: 0.85rem;
        color: #a1a8c9;
        margin-bottom: 5px;
        font-weight: 500;
      }

      .message-content {
        line-height: 1.4;
        color: #fff;
      }

      .chat-input {
        display: flex;
        gap: 12px;
        align-items: flex-end;
      }

      .chat-input textarea {
        flex: 1;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 16px;
        padding: 12px 16px;
        color: #fff;
        font-size: 0.95rem;
        resize: none;
        min-height: 45px;
        max-height: 100px;
        transition: all 0.3s ease;
      }

      .chat-input textarea::placeholder {
        color: #a1a8c9;
      }

      .chat-input textarea:focus {
        outline: none;
        border: 2px solid #6e88ff;
        box-shadow: 0 0 15px rgba(110, 136, 255, 0.2);
        background: rgba(255, 255, 255, 0.12);
      }

      .send-btn {
        background: linear-gradient(135deg, #6e88ff, #8b5aff);
        border: none;
        color: white;
        width: 45px;
        height: 45px;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        font-size: 1.2rem;
        flex-shrink: 0;
      }

      .send-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 5px 15px rgba(110, 136, 255, 0.4);
      }

      .typing-indicator {
        display: none;
        align-items: center;
        gap: 8px;
        padding: 12px 18px;
        background: linear-gradient(
          135deg,
          rgba(110, 136, 255, 0.15),
          rgba(110, 136, 255, 0.08)
        );
        border-radius: 16px;
        border-left: 3px solid #6e88ff;
        max-width: 85%;
        margin-bottom: 15px;
      }

      .typing-dots {
        display: flex;
        gap: 4px;
      }

      .typing-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #6e88ff;
        animation: typingBounce 1.4s infinite ease-in-out;
      }

      .typing-dot:nth-child(2) {
        animation-delay: 0.2s;
      }

      .typing-dot:nth-child(3) {
        animation-delay: 0.4s;
      }

      @keyframes typingBounce {
        0%,
        80%,
        100% {
          transform: scale(0);
        }
        40% {
          transform: scale(1);
        }
      }

      .mood-suggestion {
        background: linear-gradient(
          135deg,
          rgba(255, 215, 0, 0.2),
          rgba(255, 215, 0, 0.1)
        );
        border: 2px solid rgba(255, 215, 0, 0.3);
        border-radius: 12px;
        padding: 12px;
        margin-top: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .mood-suggestion:hover {
        background: linear-gradient(
          135deg,
          rgba(255, 215, 0, 0.3),
          rgba(255, 215, 0, 0.15)
        );
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(255, 215, 0, 0.2);
      }

      .mood-suggestion-text {
        font-weight: 500;
        color: #ffd700;
      }

      .mood-buttons {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 18px;
        margin-bottom: 35px;
      }

      .mood-btn {
        padding: 18px;
        border: none;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.12);
        color: #fff;
        font-size: 1.1rem;
        cursor: pointer;
        transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        position: relative;
        overflow: hidden;
      }

      .mood-btn:hover {
        transform: translateY(-5px) scale(1.05);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
      }

      .mood-btn.active {
        transform: translateY(-5px) scale(1.05);
        box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5);
        border: 2px solid rgba(255, 255, 255, 0.4);
      }

      .mood-btn.happy {
        background: linear-gradient(135deg, #ff9a9e, #fad0c4, #ffd89b);
        color: #333;
        box-shadow: 0 8px 25px rgba(255, 154, 158, 0.4);
      }
      .mood-btn.sad {
        background: linear-gradient(135deg, #4facfe, #00f2fe, #667eea);
        box-shadow: 0 8px 25px rgba(79, 172, 254, 0.4);
      }
      .mood-btn.calm {
        background: linear-gradient(135deg, #6a11cb, #2575fc, #43cea2);
        box-shadow: 0 8px 25px rgba(106, 17, 203, 0.4);
      }
      .mood-btn.energetic {
        background: linear-gradient(135deg, #f83600, #f9d423, #ff6b6b);
        color: #333;
        box-shadow: 0 8px 25px rgba(248, 54, 0, 0.4);
      }
      .mood-btn.romantic {
        background: linear-gradient(135deg, #ff057c, #8d0b93, #e94584);
        box-shadow: 0 8px 25px rgba(255, 5, 124, 0.4);
      }
      .mood-btn.focused {
        background: linear-gradient(135deg, #0ba360, #3cba92, #20bf6b);
        box-shadow: 0 8px 25px rgba(11, 163, 96, 0.4);
      }

      .text-input {
        margin-top: 30px;
      }

      textarea {
        width: 100%;
        height: 130px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 16px;
        padding: 18px;
        color: #fff;
        font-size: 1rem;
        margin-bottom: 18px;
        resize: none;
        transition: all 0.3s ease;
      }

      textarea::placeholder {
        color: #a1a8c9;
      }

      textarea:focus {
        outline: none;
        border: 2px solid #6e88ff;
        box-shadow: 0 0 20px rgba(110, 136, 255, 0.3);
        background: rgba(255, 255, 255, 0.12);
      }

      .analyze-btn {
        width: 100%;
        padding: 18px;
        border: none;
        border-radius: 16px;
        background: linear-gradient(135deg, #ff6b6b, #ff8e53, #ffa726);
        color: white;
        font-size: 1.1rem;
        cursor: pointer;
        transition: all 0.4s ease;
        box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);
      }

      .analyze-btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 12px 35px rgba(255, 107, 107, 0.5);
      }

      .player-controls {
        background: rgba(255, 255, 255, 0.08);
        border-radius: 25px;
        padding: 30px;
        margin-top: 30px;
        backdrop-filter: blur(15px);
        box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
        z-index: 10;
      }

      .song-info {
        display: flex;
        align-items: center;
        gap: 20px;
        margin-bottom: 25px;
      }

      .album-art {
        width: 90px;
        height: 90px;
        border-radius: 16px;
        background: linear-gradient(135deg, #8e2de2, #4a00e0);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2.2rem;
        box-shadow: 0 8px 25px rgba(142, 45, 226, 0.4);
        animation: pulse 2s ease-in-out infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      .song-details {
        flex: 1;
      }

      .song-title {
        font-size: 1.3rem;
        margin-bottom: 8px;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      }

      .mood-indicator {
        font-size: 1rem;
        color: #a1a8c9;
        margin-bottom: 8px;
      }

      .track-info {
        font-size: 0.9rem;
        color: #ffd700;
        text-shadow: 0 1px 5px rgba(255, 215, 0, 0.3);
      }

      .progress-container {
        width: 100%;
        height: 8px;
        background: rgba(255, 255, 255, 0.12);
        border-radius: 4px;
        margin: 20px 0;
        cursor: pointer;
        position: relative;
        overflow: hidden;
      }

      .progress-bar {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #6e88ff, #ff6b6b, #ffd700);
        border-radius: 4px;
        transition: width 0.1s linear;
        box-shadow: 0 0 10px rgba(110, 136, 255, 0.5);
      }

      .controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 25px;
      }

      .control-btn {
        background: none;
        border: none;
        color: #fff;
        font-size: 1.6rem;
        cursor: pointer;
        padding: 12px;
        transition: all 0.3s ease;
        border-radius: 50%;
      }

      .control-btn:hover {
        color: #6e88ff;
        transform: scale(1.2);
        background: rgba(110, 136, 255, 0.2);
      }

      .play-btn {
        background: linear-gradient(135deg, #6e88ff, #ff6b6b);
        width: 70px;
        height: 70px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2rem;
        box-shadow: 0 8px 30px rgba(110, 136, 255, 0.5);
        transition: all 0.3s ease;
      }

      .play-btn:hover {
        transform: scale(1.1);
        box-shadow: 0 12px 40px rgba(110, 136, 255, 0.6);
      }

      /* New styles for shuffle and sequential buttons */
      .mode-btn {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #fff;
        padding: 10px 16px;
        border-radius: 20px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 0.9rem;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .mode-btn:hover {
        background: rgba(110, 136, 255, 0.3);
        border-color: #6e88ff;
        transform: translateY(-2px);
      }

      .mode-btn.active {
        background: rgba(110, 136, 255, 0.5);
        border-color: #6e88ff;
        box-shadow: 0 4px 15px rgba(110, 136, 255, 0.3);
      }

      #three-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      .mood-display {
        position: absolute;
        bottom: 25px;
        right: 25px;
        background: rgba(0, 0, 0, 0.6);
        padding: 15px 25px;
        border-radius: 25px;
        font-size: 1.3rem;
        z-index: 11;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .fullscreen-btn {
        position: absolute;
        bottom: 25px;
        left: 25px;
        background: rgba(0, 0, 0, 0.6);
        border: none;
        color: #fff;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        font-size: 1.4rem;
        cursor: pointer;
        transition: all 0.3s ease;
        z-index: 11;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .fullscreen-btn:hover {
        background: rgba(110, 136, 255, 0.8);
        transform: scale(1.1);
        box-shadow: 0 8px 25px rgba(110, 136, 255, 0.5);
      }

      .visualization.fullscreen {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        z-index: 9999 !important;
        border-radius: 0 !important;
      }

      .mood-text {
        color: #ff6b6b;
        font-weight: bold;
        text-shadow: 0 2px 10px rgba(255, 107, 107, 0.5);
      }

      footer {
        text-align: center;
        padding: 30px 0;
        color: #a1a8c9;
        font-size: 1rem;
        z-index: 10;
      }

      @media (max-width: 1200px) {
        .main-content {
          flex-direction: column;
        }
        .left-panel {
          flex-direction: row;
        }
        .ai-chat {
          min-height: 350px;
        }
        h1 {
          font-size: 3rem;
        }
      }

      @media (max-width: 800px) {
        .left-panel {
          flex-direction: column;
        }
        .controls {
          flex-wrap: wrap;
          gap: 10px;
          justify-content: center;
        }
        .mode-btn {
          font-size: 0.8rem;
          padding: 8px 12px;
        }
      }

      .chat-messages::-webkit-scrollbar {
        width: 6px;
      }
      .chat-messages::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 3px;
      }
      .chat-messages::-webkit-scrollbar-thumb {
        background: rgba(110, 136, 255, 0.4);
        border-radius: 3px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>MoodTune</h1>
        <p class="tagline">Your emotion-based music experience</p>
      </header>

      <div class="main-content">
        <div class="left-panel">
          <div class="ai-chat">
            <h2 class="section-title">Chat with MoodBot</h2>
            <div class="chat-messages" id="chat-messages">
              <div class="message ai">
                <div class="message-header">MoodBot</div>
                <div class="message-content">
                  Hello! I'm here to help you find the perfect music for your
                  mood. How are you feeling today? Tell me what's on your mind.
                </div>
              </div>
            </div>
            <div class="typing-indicator" id="typing-indicator">
              <div class="message-header">MoodBot is thinking...</div>
              <div class="typing-dots">
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
              </div>
            </div>
            <div class="chat-input">
              <textarea
                id="chat-input"
                placeholder="Tell me how you're feeling..."
                rows="1"
              ></textarea>
              <button class="send-btn" id="send-btn">‚û§</button>
            </div>
          </div>

          <div class="mood-selector">
            <h2 class="section-title">Quick Mood Select</h2>
            <div class="mood-buttons">
              <button class="mood-btn happy" data-mood="happy">üòä Happy</button>
              <button class="mood-btn sad" data-mood="sad">üò¢ Sad</button>
              <button class="mood-btn calm" data-mood="calm">üòå Calm</button>
              <button class="mood-btn energetic" data-mood="energetic">
                ‚ö° Energetic
              </button>
              <button class="mood-btn romantic" data-mood="romantic">
                ‚ù§Ô∏è Romantic
              </button>
              <button class="mood-btn focused" data-mood="focused">
                üéØ Focused
              </button>
            </div>

            <div class="text-input">
              <h2 class="section-title">Tell me how you are feeling?</h2>
              <textarea
                id="mood-text"
                placeholder="Type how you're feeling today..."
              ></textarea>
              <button class="analyze-btn" id="analyze-btn">
                Analyze My Text
              </button>
            </div>
          </div>
        </div>

        <div class="visualization" id="visualization-container">
          <canvas id="three-canvas"></canvas>
          <div class="mood-display">
            Current Mood:
            <span class="mood-text" id="current-mood-display">None</span>
          </div>
          <button
            class="fullscreen-btn"
            id="fullscreen-btn"
            title="Toggle Fullscreen"
          >
            ‚õ∂
          </button>
        </div>
      </div>

      <div class="player-controls">
        <div class="song-info">
          <div class="album-art">üéµ</div>
          <div class="song-details">
            <div class="song-title" id="song-title">
              Chat with MoodBot to start your musical journey
            </div>
            <div class="mood-indicator" id="mood-indicator">Mood: None</div>
            <div class="track-info" id="track-info">Track 1 of 8</div>
          </div>
        </div>

        <div class="progress-container">
          <div class="progress-bar" id="progress-bar"></div>
        </div>

        <div class="controls">
          <button class="mode-btn active" id="shuffle-btn">üîÄ</button>
          <button class="control-btn" id="prev-btn">‚èÆ</button>
          <button class="play-btn control-btn" id="play-btn">‚ñ∂</button>
          <button class="control-btn" id="next-btn">‚è≠</button>
          <button class="mode-btn" id="sequential-btn">üîÅ</button>
        </div>
      </div>

      <footer>
        <p>MoodTune ¬© JinhuiLiang | AI-Enhanced Emotion-Based Music Player</p>
      </footer>
    </div>

    <script>
      // Global variables
      let currentMood = null;
      let isPlaying = false;
      let progressInterval;
      let currentAudio = null;
      let audioContext = null;
      let isFullscreen = false;
      let userInteracted = false;
      let chatHistory = [];
      let isTyping = false;

      // Playlist variables
      let currentPlaylist = [];
      let currentTrackIndex = 0;
      let isShuffleMode = true;
      let shuffleOrder = [];

      // Three.js variables
      let scene, camera, renderer;
      let animationFrame;
      let moodObjects = [];
      let time = 0;
      let particleSystems = [];
      let audioAnalyser = null;
      let audioData = null;
      let isAudioAnalyzerReady = false;

      // Mood to music playlists mapping - UPDATED TO 8 SONGS PER MOOD
      const moodPlaylists = {
        happy: {
          name: "Happy Vibes",
          color: [255, 223, 100],
          energy: 0.8,
          tracks: [
            { title: "Sunshine Day - Upbeat Pop", file: "audio/happy.mp3" },
            { title: "Good Vibes Only - Feel Good", file: "audio/happy2.mp3" },
            { title: "Dancing Colors - Joyful Beat", file: "audio/happy3.mp3" },
            {
              title: "Morning Joy - Bright Melodies",
              file: "audio/happy4.mp3",
            },
            {
              title: "Positive Energy - Happy Rhythms",
              file: "audio/happy5.mp3",
            },
            { title: "Cheerful Moments - Uplifting", file: "audio/happy6.mp3" },
            { title: "Smile Factory - Pure Joy", file: "audio/happy7.mp3" },
            { title: "Golden Hour - Radiant Beats", file: "audio/happy8.mp3" },
          ],
        },
        sad: {
          name: "Melancholic Moods",
          color: [100, 150, 255],
          energy: 0.3,
          tracks: [
            { title: "Rainy Nights - Melancholic", file: "audio/sad.mp3" },
            { title: "Gentle Tears - Emotional", file: "audio/sad2.mp3" },
            {
              title: "Blue Reflections - Contemplative",
              file: "audio/sad3.mp3",
            },
            { title: "Lonely Echoes - Deep Thoughts", file: "audio/sad4.mp3" },
            { title: "Fading Memories - Nostalgic", file: "audio/sad5.mp3" },
            { title: "Silent Sorrow - Melancholy", file: "audio/sad6.mp3" },
            { title: "Distant Dreams - Wistful", file: "audio/sad7.mp3" },
            { title: "Twilight Blues - Reflective", file: "audio/sad8.mp3" },
          ],
        },
        calm: {
          name: "Peaceful Moments",
          color: [100, 220, 200],
          energy: 0.4,
          tracks: [
            { title: "Tranquil Waters - Ambient", file: "audio/calm.mp3" },
            { title: "Serene Forest - Nature Sounds", file: "audio/calm2.mp3" },
            { title: "Zen Garden - Meditation", file: "audio/calm3.mp3" },
            { title: "Peaceful Mind - Gentle Flow", file: "audio/calm4.mp3" },
            { title: "Still Moments - Quiet Harmony", file: "audio/calm5.mp3" },
            { title: "Soft Breeze - Relaxation", file: "audio/calm6.mp3" },
            { title: "Inner Peace - Meditation", file: "audio/calm7.mp3" },
            { title: "Floating Dreams - Tranquil", file: "audio/calm8.mp3" },
          ],
        },
        energetic: {
          name: "High Energy",
          color: [255, 100, 100],
          energy: 0.9,
          tracks: [
            { title: "Electric Pulse - Dance", file: "audio/energetic.mp3" },
            { title: "Power Drive - Electronic", file: "audio/energetic2.mp3" },
            {
              title: "Adrenaline Rush - Intense",
              file: "audio/energetic3.mp3",
            },
            {
              title: "Thunder Storm - Powerful Beats",
              file: "audio/energetic4.mp3",
            },
            {
              title: "Fire Energy - Explosive Rhythms",
              file: "audio/energetic5.mp3",
            },
            {
              title: "Turbo Charged - High Octane",
              file: "audio/energetic6.mp3",
            },
            {
              title: "Lightning Strike - Dynamic",
              file: "audio/energetic7.mp3",
            },
            {
              title: "Maximum Velocity - Intense",
              file: "audio/energetic8.mp3",
            },
          ],
        },
        romantic: {
          name: "Love Songs",
          color: [255, 100, 200],
          energy: 0.6,
          tracks: [
            { title: "Hearts Entwined - Romance", file: "audio/romantic.mp3" },
            { title: "Sweet Serenade - Intimate", file: "audio/romantic2.mp3" },
            { title: "Moonlight Dance - Tender", file: "audio/romantic3.mp3" },
            { title: "Eternal Love - Passionate", file: "audio/romantic4.mp3" },
            {
              title: "Whispered Promises - Gentle",
              file: "audio/romantic5.mp3",
            },
            { title: "Velvet Kiss - Sensual", file: "audio/romantic6.mp3" },
            { title: "Love Letters - Heartfelt", file: "audio/romantic7.mp3" },
            { title: "Starlit Romance - Dreamy", file: "audio/romantic8.mp3" },
          ],
        },
        focused: {
          name: "Focus Zone",
          color: [150, 200, 255],
          energy: 0.5,
          tracks: [
            {
              title: "Concentration Zone - Deep Focus",
              file: "audio/focused.mp3",
            },
            { title: "Mind Flow - Productivity", file: "audio/focused2.mp3" },
            {
              title: "Study Session - Ambient Work",
              file: "audio/focused3.mp3",
            },
            {
              title: "Mental Clarity - Cognitive Boost",
              file: "audio/focused4.mp3",
            },
            { title: "Deep Work - Intense Focus", file: "audio/focused5.mp3" },
            {
              title: "Brain Power - Concentration",
              file: "audio/focused6.mp3",
            },
            { title: "Task Master - Productivity", file: "audio/focused7.mp3" },
            {
              title: "Flow State - Peak Performance",
              file: "audio/focused8.mp3",
            },
          ],
        },
      };

      // AI Chat System
      const moodKeywords = {
        happy: {
          keywords: [
            "happy",
            "joy",
            "excited",
            "great",
            "awesome",
            "wonderful",
            "amazing",
            "fantastic",
            "good",
            "cheerful",
            "bright",
            "celebrate",
            "thrilled",
            "upbeat",
            "positive",
          ],
          responses: [
            "That's wonderful to hear! Your positive energy is contagious. Let me set up some upbeat music to match your mood.",
            "I love that enthusiasm! Happy vibes deserve happy music. Getting some sunshine sounds ready for you.",
            "What a great mood you're in! Time for some energetic tunes to keep those good feelings flowing.",
          ],
        },
        sad: {
          keywords: [
            "sad",
            "down",
            "depressed",
            "blue",
            "upset",
            "hurt",
            "cry",
            "tears",
            "lonely",
            "empty",
            "disappointed",
            "heartbroken",
            "grief",
            "loss",
            "melancholy",
          ],
          responses: [
            "I understand you're going through a tough time. Sometimes melancholic music can be comforting and help process these feelings.",
            "It's okay to feel sad sometimes. Let me find some gentle, contemplative music that might resonate with your current state.",
            "Sadness is a valid emotion. Would some soothing, reflective music help you work through what you're feeling?",
          ],
        },
        calm: {
          keywords: [
            "calm",
            "peaceful",
            "relaxed",
            "zen",
            "tranquil",
            "serene",
            "quiet",
            "still",
            "centered",
            "meditative",
            "chill",
            "mellow",
            "restful",
            "soothing",
          ],
          responses: [
            "A peaceful state of mind is beautiful. Let me create a tranquil soundscape to enhance your sense of calm.",
            "Zen vibes detected! Time for some ambient, flowing music to complement your inner peace.",
            "That sounds wonderfully serene. I'll set up some meditative tunes to maintain that peaceful energy.",
          ],
        },
        energetic: {
          keywords: [
            "energy",
            "pumped",
            "hyped",
            "active",
            "dynamic",
            "powerful",
            "intense",
            "charged",
            "electric",
            "motivated",
            "driven",
            "fired up",
            "amped",
            "vigorous",
          ],
          responses: [
            "I can feel that energy! Time to channel it with some high-octane music that matches your intensity.",
            "You're charged up and ready to go! Let me find some powerful beats to fuel that momentum.",
            "That's the spirit! High-energy music coming right up to match your dynamic mood.",
          ],
        },
        romantic: {
          keywords: [
            "love",
            "romance",
            "heart",
            "romantic",
            "intimate",
            "passion",
            "sweet",
            "tender",
            "affection",
            "relationship",
            "partner",
            "date",
            "valentine",
            "crush",
          ],
          responses: [
            "Love is in the air! Let me set a romantic atmosphere with some beautiful, heartfelt melodies.",
            "Aww, that's sweet! Time for some tender, romantic music to complement those lovely feelings.",
            "Romance calls for special music. I'll create the perfect soundtrack for your heart's desires.",
          ],
        },
        focused: {
          keywords: [
            "focus",
            "concentrate",
            "work",
            "study",
            "productive",
            "clear",
            "sharp",
            "determined",
            "mindful",
            "task",
            "project",
            "deadline",
            "learning",
            "analysis",
          ],
          responses: [
            "Time to get in the zone! I'll set up some focused, concentration-enhancing music for maximum productivity.",
            "Perfect mindset for deep work. Let me create an audio environment that supports your concentration.",
            "That focused energy is powerful. Here's some music designed to enhance cognitive performance and maintain attention.",
          ],
        },
      };

      const conversationStarters = [
        "What's been the highlight of your day so far?",
        "Tell me about something that's been on your mind lately.",
        "How would you describe your energy level right now?",
        "What kind of atmosphere would make you feel most comfortable?",
        "Are there any particular emotions you've been experiencing today?",
      ];

      const followUpQuestions = {
        happy: [
          "What's making you feel so positive today?",
          "How would you like to celebrate this mood?",
        ],
        sad: [
          "Would you like to talk about what's troubling you?",
          "Sometimes music helps - shall we find something soothing?",
        ],
        calm: [
          "What helps you maintain this peaceful state?",
          "Are you looking to stay relaxed or perhaps energize yourself?",
        ],
        energetic: [
          "What's fueling this amazing energy?",
          "Ready to channel this into something creative or active?",
        ],
        romantic: [
          "Is there someone special you're thinking about?",
          "What kind of romantic atmosphere appeals to you?",
        ],
        focused: [
          "What are you working on that requires this concentration?",
          "How can I best support your productive mindset?",
        ],
      };

      // Enhanced Three.js Initialization
      function initThree() {
        const container = document.getElementById("visualization-container");
        const canvas = document.getElementById("three-canvas");

        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x0a0a15, 0.02);

        camera = new THREE.PerspectiveCamera(
          75,
          container.clientWidth / container.clientHeight,
          0.1,
          1000
        );
        camera.position.z = 30;

        renderer = new THREE.WebGLRenderer({
          canvas: canvas,
          antialias: true,
          alpha: true,
        });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Enhanced lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0xffffff, 0.5, 100);
        pointLight.position.set(0, 10, 10);
        scene.add(pointLight);

        // Initialize audio analyzer
        initializeAudioAnalyzer();

        animate3D();
      }

      function initializeAudioAnalyzer() {
        if (!audioContext) {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
        }

        audioAnalyser = audioContext.createAnalyser();
        audioAnalyser.fftSize = 256;
        audioData = new Uint8Array(audioAnalyser.frequencyBinCount);
        isAudioAnalyzerReady = true;
      }

      function connectAudioToAnalyzer(audioElement) {
        if (!isAudioAnalyzerReady || !audioContext) return;

        try {
          const source = audioContext.createMediaElementSource(audioElement);
          source.connect(audioAnalyser);
          audioAnalyser.connect(audioContext.destination);
        } catch (error) {
          console.log("Audio analyzer connection failed:", error);
        }
      }

      function clearMoodObjects() {
        moodObjects.forEach((obj) => {
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material)) {
              obj.material.forEach((mat) => mat.dispose());
            } else {
              obj.material.dispose();
            }
          }
          scene.remove(obj);
        });
        moodObjects = [];

        // Clear particle systems
        particleSystems.forEach((system) => {
          scene.remove(system);
          if (system.geometry) system.geometry.dispose();
          if (system.material) system.material.dispose();
        });
        particleSystems = [];
      }

      // Enhanced Mood-specific 3D animations with audio reactivity
      function createHappyAnimation3D() {
        clearMoodObjects();

        // Create a central sun-like object with glow effect
        const sunGeometry = new THREE.SphereGeometry(3, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({
          color: 0xffd700,
          emissive: 0xffd700,
          emissiveIntensity: 0.8,
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);
        moodObjects.push(sun);

        // Create glow effect
        const glowGeometry = new THREE.SphereGeometry(4, 32, 32);
        const glowMaterial = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            color: { value: new THREE.Color(0xffd700) },
          },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform float time;
            uniform vec3 color;
            varying vec2 vUv;
            void main() {
              float intensity = 0.6 + 0.4 * sin(time * 2.0);
              vec3 finalColor = color * intensity;
              gl_FragColor = vec4(finalColor, 0.3);
            }
          `,
          transparent: true,
          side: THREE.BackSide,
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        scene.add(glow);
        moodObjects.push(glow);

        // Create orbiting planets with trails
        for (let i = 0; i < 8; i++) {
          const size = Math.random() * 0.8 + 0.5;
          const geometry = new THREE.IcosahedronGeometry(size, 2);
          const material = new THREE.MeshPhongMaterial({
            color: new THREE.Color(`hsl(${Math.random() * 60 + 30}, 90%, 70%)`),
            emissive: new THREE.Color(
              `hsl(${Math.random() * 60 + 30}, 90%, 30%)`
            ),
            shininess: 100,
          });

          const planet = new THREE.Mesh(geometry, material);
          const orbitRadius = 8 + i * 2;
          const orbitSpeed = 0.003 + Math.random() * 0.003;

          planet.position.set(
            Math.cos(i) * orbitRadius,
            (Math.sin(i) * orbitRadius) / 2,
            (Math.sin(i) * orbitRadius) / 3
          );

          planet.userData = {
            orbitRadius: orbitRadius,
            orbitSpeed: orbitSpeed,
            angle: (i * Math.PI) / 4,
            trail: [],
          };

          scene.add(planet);
          moodObjects.push(planet);

          // Create trail
          for (let j = 0; j < 5; j++) {
            const trailGeometry = new THREE.SphereGeometry(size * 0.3, 8, 8);
            const trailMaterial = new THREE.MeshBasicMaterial({
              color: material.color,
              transparent: true,
              opacity: 0.3 - j * 0.06,
            });
            const trail = new THREE.Mesh(trailGeometry, trailMaterial);
            trail.position.copy(planet.position);
            scene.add(trail);
            planet.userData.trail.push({
              mesh: trail,
              age: j,
            });
          }
        }

        // Enhanced particle system for confetti
        const particleCount = 800;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount * 3);
        const rotations = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i += 3) {
          positions[i] = (Math.random() - 0.5) * 50;
          positions[i + 1] = (Math.random() - 0.5) * 50;
          positions[i + 2] = (Math.random() - 0.5) * 50;

          colors[i] = Math.random();
          colors[i + 1] = Math.random();
          colors[i + 2] = Math.random();

          velocities[i] = (Math.random() - 0.5) * 0.1;
          velocities[i + 1] = (Math.random() - 0.5) * 0.1;
          velocities[i + 2] = (Math.random() - 0.5) * 0.1;

          rotations[i] = Math.random() * Math.PI * 2;
          rotations[i + 1] = Math.random() * Math.PI * 2;
          rotations[i + 2] = Math.random() * Math.PI * 2;
        }

        particles.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        particles.setAttribute("color", new THREE.BufferAttribute(colors, 3));
        particles.setAttribute(
          "velocity",
          new THREE.BufferAttribute(velocities, 3)
        );
        particles.setAttribute(
          "rotation",
          new THREE.BufferAttribute(rotations, 3)
        );

        const particleMaterial = new THREE.PointsMaterial({
          size: 0.4,
          vertexColors: true,
          transparent: true,
          opacity: 0.8,
          sizeAttenuation: true,
        });

        const particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);
        particleSystems.push(particleSystem);

        // Add dynamic lighting
        const pointLight = new THREE.PointLight(0xffd700, 2, 50);
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);
        moodObjects.push(pointLight);
      }

      function createSadAnimation3D() {
        clearMoodObjects();

        // Create a dark, stormy scene with volumetric clouds
        const cloudCount = 8;
        for (let i = 0; i < cloudCount; i++) {
          const cloudGeometry = new THREE.SphereGeometry(
            3 + Math.random() * 4,
            7,
            7
          );
          const cloudMaterial = new THREE.MeshPhongMaterial({
            color: 0x2c3e50,
            emissive: 0x2c3e50,
            emissiveIntensity: 0.1,
            transparent: true,
            opacity: 0.6,
          });

          const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
          cloud.position.set(
            (Math.random() - 0.5) * 40,
            5 + Math.random() * 15,
            (Math.random() - 0.5) * 30
          );
          cloud.scale.set(
            1 + Math.random() * 0.8,
            0.5 + Math.random() * 0.4,
            1 + Math.random() * 0.8
          );
          cloud.userData = {
            driftSpeed: 0.005 + Math.random() * 0.01,
            pulsePhase: Math.random() * Math.PI * 2,
          };
          scene.add(cloud);
          moodObjects.push(cloud);
        }

        // Enhanced rain particles with splashes
        const rainCount = 2000;
        const rainGeometry = new THREE.BufferGeometry();
        const rainPositions = new Float32Array(rainCount * 3);
        const rainVelocities = new Float32Array(rainCount);
        const rainSizes = new Float32Array(rainCount);

        for (let i = 0; i < rainCount * 3; i += 3) {
          rainPositions[i] = (Math.random() - 0.5) * 60;
          rainPositions[i + 1] = Math.random() * 50;
          rainPositions[i + 2] = (Math.random() - 0.5) * 60;
          rainVelocities[i / 3] = 0.3 + Math.random() * 0.4;
          rainSizes[i / 3] = 0.1 + Math.random() * 0.2;
        }

        rainGeometry.setAttribute(
          "position",
          new THREE.BufferAttribute(rainPositions, 3)
        );
        rainGeometry.userData = {
          velocities: rainVelocities,
          sizes: rainSizes,
        };

        const rainMaterial = new THREE.PointsMaterial({
          color: 0x6495ed,
          size: 0.2,
          transparent: true,
          opacity: 0.8,
          sizeAttenuation: true,
        });

        const rain = new THREE.Points(rainGeometry, rainMaterial);
        scene.add(rain);
        moodObjects.push(rain);

        // Create lightning effect
        const lightningGroup = new THREE.Group();
        scene.add(lightningGroup);
        moodObjects.push(lightningGroup);

        // Add blue-tinted lighting with occasional flashes
        const ambientLight = new THREE.AmbientLight(0x4169e1, 0.2);
        scene.add(ambientLight);
        moodObjects.push(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0x6495ed, 0.4);
        directionalLight.position.set(0, 10, 0);
        scene.add(directionalLight);
        moodObjects.push(directionalLight);
      }

      function createCalmAnimation3D() {
        clearMoodObjects();

        // Create an underwater scene with coral and animated plants
        const waterGeometry = new THREE.BoxGeometry(80, 50, 80);
        const waterMaterial = new THREE.MeshPhongMaterial({
          color: 0x1e90ff,
          transparent: true,
          opacity: 0.08,
          side: THREE.BackSide,
        });

        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        scene.add(water);
        moodObjects.push(water);

        // Create coral formations with more variety
        const coralTypes = [
          THREE.ConeGeometry,
          THREE.CylinderGeometry,
          THREE.SphereGeometry,
        ];
        for (let i = 0; i < 25; i++) {
          const coralType =
            coralTypes[Math.floor(Math.random() * coralTypes.length)];
          let coralGeometry;

          if (coralType === THREE.ConeGeometry) {
            coralGeometry = new coralType(
              0.5 + Math.random() * 1.5,
              3 + Math.random() * 5,
              4 + Math.floor(Math.random() * 4)
            );
          } else if (coralType === THREE.CylinderGeometry) {
            coralGeometry = new coralType(
              0.3 + Math.random() * 0.7,
              0.5 + Math.random() * 1,
              2 + Math.random() * 4,
              6
            );
          } else {
            coralGeometry = new coralType(0.8 + Math.random() * 1.2, 8, 8);
          }

          const coralMaterial = new THREE.MeshPhongMaterial({
            color: new THREE.Color(
              `hsl(${Math.random() * 30 + 330}, 70%, 60%)`
            ),
            emissive: new THREE.Color(
              `hsl(${Math.random() * 30 + 330}, 70%, 20%)`
            ),
            shininess: 30,
          });

          const coral = new THREE.Mesh(coralGeometry, coralMaterial);
          coral.position.set(
            (Math.random() - 0.5) * 50,
            -20 + Math.random() * 10,
            (Math.random() - 0.5) * 50
          );
          coral.rotation.x = Math.random() * Math.PI;
          coral.rotation.z = Math.random() * Math.PI;
          coral.userData = {
            swaySpeed: 0.01 + Math.random() * 0.02,
            swayPhase: Math.random() * Math.PI * 2,
          };

          scene.add(coral);
          moodObjects.push(coral);
        }

        // Enhanced bubble particle system
        const bubbleCount = 150;
        const bubbleGeometry = new THREE.BufferGeometry();
        const bubblePositions = new Float32Array(bubbleCount * 3);
        const bubbleSizes = new Float32Array(bubbleCount);
        const bubbleSpeeds = new Float32Array(bubbleCount);

        for (let i = 0; i < bubbleCount * 3; i += 3) {
          bubblePositions[i] = (Math.random() - 0.5) * 50;
          bubblePositions[i + 1] = -25 + Math.random() * 15;
          bubblePositions[i + 2] = (Math.random() - 0.5) * 50;
          bubbleSizes[i / 3] = 0.3 + Math.random() * 0.7;
          bubbleSpeeds[i / 3] = 0.03 + Math.random() * 0.05;
        }

        bubbleGeometry.setAttribute(
          "position",
          new THREE.BufferAttribute(bubblePositions, 3)
        );
        bubbleGeometry.userData = {
          sizes: bubbleSizes,
          speeds: bubbleSpeeds,
        };

        const bubbleMaterial = new THREE.PointsMaterial({
          color: 0x87ceeb,
          size: 0.6,
          transparent: true,
          opacity: 0.7,
          blending: THREE.AdditiveBlending,
          sizeAttenuation: true,
        });

        const bubbles = new THREE.Points(bubbleGeometry, bubbleMaterial);
        scene.add(bubbles);
        moodObjects.push(bubbles);

        // Add caustic lighting effect
        const directionalLight = new THREE.DirectionalLight(0x87ceeb, 0.9);
        directionalLight.position.set(10, 25, 10);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        moodObjects.push(directionalLight);

        const pointLight = new THREE.PointLight(0x40e0d0, 0.6, 40);
        pointLight.position.set(0, 15, 0);
        scene.add(pointLight);
        moodObjects.push(pointLight);
      }

      function createEnergeticAnimation3D() {
        clearMoodObjects();

        // Create a pulsating energy core with multiple layers
        const coreGeometry = new THREE.IcosahedronGeometry(4, 3);
        const coreMaterial = new THREE.MeshPhongMaterial({
          color: 0xff4500,
          emissive: 0xff4500,
          emissiveIntensity: 0.9,
          wireframe: false,
          transparent: true,
          opacity: 0.95,
        });

        const core = new THREE.Mesh(coreGeometry, coreMaterial);
        scene.add(core);
        moodObjects.push(core);

        // Create outer energy shell
        const shellGeometry = new THREE.IcosahedronGeometry(6, 2);
        const shellMaterial = new THREE.MeshBasicMaterial({
          color: 0xffa500,
          wireframe: true,
          transparent: true,
          opacity: 0.6,
        });
        const shell = new THREE.Mesh(shellGeometry, shellMaterial);
        scene.add(shell);
        moodObjects.push(shell);

        // Create energy beams with improved geometry
        const beamCount = 16;
        for (let i = 0; i < beamCount; i++) {
          const beamGeometry = new THREE.CylinderGeometry(0.1, 0.8, 18, 12);
          const beamMaterial = new THREE.MeshPhongMaterial({
            color: 0xffa500,
            emissive: 0xffa500,
            emissiveIntensity: 0.8,
            transparent: true,
            opacity: 0.85,
          });

          const beam = new THREE.Mesh(beamGeometry, beamMaterial);
          const angle = (i / beamCount) * Math.PI * 2;
          const radius = 12;
          beam.position.set(
            Math.cos(angle) * radius,
            Math.sin(angle) * radius,
            0
          );
          beam.rotation.z = angle + Math.PI / 2;
          beam.lookAt(0, 0, 0);

          beam.userData = {
            angle: angle,
            pulsePhase: Math.random() * Math.PI * 2,
            radius: radius,
          };

          scene.add(beam);
          moodObjects.push(beam);
        }

        // Enhanced orbiting particles with trails
        const particleCount = 300;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);

        for (let i = 0; i < particleCount * 3; i += 3) {
          const radius = 12 + Math.random() * 20;
          const angle = Math.random() * Math.PI * 2;
          const height = (Math.random() - 0.5) * 15;

          positions[i] = Math.cos(angle) * radius;
          positions[i + 1] = height;
          positions[i + 2] = Math.sin(angle) * radius;

          // Tangential velocity for orbit
          const speed = 0.05 + Math.random() * 0.08;
          velocities[i] = -Math.sin(angle) * speed;
          velocities[i + 1] = (Math.random() - 0.5) * 0.02;
          velocities[i + 2] = Math.cos(angle) * speed;

          colors[i] = 0.9 + Math.random() * 0.1;
          colors[i + 1] = 0.4 + Math.random() * 0.3;
          colors[i + 2] = 0.1 + Math.random() * 0.2;

          sizes[i / 3] = 0.2 + Math.random() * 0.3;
        }

        particles.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        particles.setAttribute(
          "velocity",
          new THREE.BufferAttribute(velocities, 3)
        );
        particles.setAttribute("color", new THREE.BufferAttribute(colors, 3));
        particles.setAttribute("size", new THREE.BufferAttribute(sizes, 1));

        const particleMaterial = new THREE.PointsMaterial({
          size: 0.3,
          vertexColors: true,
          transparent: true,
          opacity: 0.9,
          blending: THREE.AdditiveBlending,
          sizeAttenuation: true,
        });

        const particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);
        particleSystems.push(particleSystem);

        // Add dynamic lighting
        const pointLight = new THREE.PointLight(0xff4500, 3, 60);
        pointLight.position.set(0, 0, 0);
        scene.add(pointLight);
        moodObjects.push(pointLight);

        const directionalLight = new THREE.DirectionalLight(0xffa500, 0.7);
        directionalLight.position.set(15, 15, 15);
        scene.add(directionalLight);
        moodObjects.push(directionalLight);
      }

      function createRomanticAnimation3D() {
        clearMoodObjects();

        // Create multiple floating hearts
        const heartCount = 5;
        for (let h = 0; h < heartCount; h++) {
          const heartShape = new THREE.Shape();
          heartShape.moveTo(0, 0);
          heartShape.bezierCurveTo(2, 2, 4, 0, 0, -3);
          heartShape.bezierCurveTo(-4, 0, -2, 2, 0, 0);

          const heartGeometry = new THREE.ExtrudeGeometry(heartShape, {
            depth: 0.3,
            bevelEnabled: true,
            bevelThickness: 0.1,
            bevelSize: 0.1,
            bevelSegments: 8,
          });

          const heartMaterial = new THREE.MeshPhongMaterial({
            color: 0xff1493,
            emissive: 0xff1493,
            emissiveIntensity: 0.4,
            shininess: 100,
          });

          const heart = new THREE.Mesh(heartGeometry, heartMaterial);
          heart.scale.set(1.2, 1.2, 1.2);
          heart.position.set(
            (Math.random() - 0.5) * 20,
            (Math.random() - 0.5) * 12,
            (Math.random() - 0.5) * 15
          );
          heart.rotation.x = Math.random() * Math.PI;
          heart.rotation.y = Math.random() * Math.PI;

          heart.userData = {
            floatSpeed: 0.003 + Math.random() * 0.003,
            rotationSpeed: (Math.random() - 0.5) * 0.01,
            floatOffset: Math.random() * Math.PI * 2,
            originalPosition: heart.position.clone(),
          };

          scene.add(heart);
          moodObjects.push(heart);
        }

        // Enhanced floating rose petals with more natural movement
        const petalCount = 80;
        const petalGeometry = new THREE.PlaneGeometry(0.8, 0.5);
        const petalMaterial = new THREE.MeshPhongMaterial({
          color: 0xff69b4,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.8,
          shininess: 30,
        });

        for (let i = 0; i < petalCount; i++) {
          const petal = new THREE.Mesh(petalGeometry, petalMaterial);
          petal.position.set(
            (Math.random() - 0.5) * 35,
            (Math.random() - 0.5) * 25,
            (Math.random() - 0.5) * 25
          );
          petal.rotation.x = Math.random() * Math.PI;
          petal.rotation.y = Math.random() * Math.PI;
          petal.rotation.z = Math.random() * Math.PI;

          petal.userData = {
            floatSpeed: 0.004 + Math.random() * 0.004,
            rotationSpeed: (Math.random() - 0.5) * 0.015,
            floatOffset: Math.random() * Math.PI * 2,
            drift: new THREE.Vector3(
              (Math.random() - 0.5) * 0.002,
              (Math.random() - 0.5) * 0.001,
              (Math.random() - 0.5) * 0.002
            ),
          };

          scene.add(petal);
          moodObjects.push(petal);
        }

        // Enhanced glowing particles with color variation
        const particleCount = 150;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        const pulses = new Float32Array(particleCount);

        for (let i = 0; i < particleCount * 3; i += 3) {
          positions[i] = (Math.random() - 0.5) * 30;
          positions[i + 1] = (Math.random() - 0.5) * 20;
          positions[i + 2] = (Math.random() - 0.5) * 20;

          // Vary between pink and purple
          const hue = 330 + Math.random() * 30;
          const color = new THREE.Color(`hsl(${hue}, 90%, 70%)`);
          colors[i] = color.r;
          colors[i + 1] = color.g;
          colors[i + 2] = color.b;

          sizes[i / 3] = 0.15 + Math.random() * 0.25;
          pulses[i / 3] = Math.random() * Math.PI * 2;
        }

        particles.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        particles.setAttribute("color", new THREE.BufferAttribute(colors, 3));
        particles.setAttribute("size", new THREE.BufferAttribute(sizes, 1));
        particles.setAttribute("pulse", new THREE.BufferAttribute(pulses, 1));

        const particleMaterial = new THREE.PointsMaterial({
          size: 0.2,
          vertexColors: true,
          transparent: true,
          opacity: 0.9,
          blending: THREE.AdditiveBlending,
          sizeAttenuation: true,
        });

        const particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);
        particleSystems.push(particleSystem);

        // Add romantic lighting with multiple sources
        const pointLight1 = new THREE.PointLight(0xff1493, 2, 35);
        pointLight1.position.set(12, 8, 12);
        scene.add(pointLight1);
        moodObjects.push(pointLight1);

        const pointLight2 = new THREE.PointLight(0xff69b4, 1.5, 30);
        pointLight2.position.set(-12, 5, -12);
        scene.add(pointLight2);
        moodObjects.push(pointLight2);

        const pointLight3 = new THREE.PointLight(0x8b008b, 1, 25);
        pointLight3.position.set(0, -5, 0);
        scene.add(pointLight3);
        moodObjects.push(pointLight3);

        const ambientLight = new THREE.AmbientLight(0x8b008b, 0.4);
        scene.add(ambientLight);
        moodObjects.push(ambientLight);
      }

      function createFocusedAnimation3D() {
        clearMoodObjects();

        // Create a neural network-like structure with more complexity
        const nodeCount = 40;
        const nodes = [];
        const connections = [];

        // Create nodes with varied sizes
        for (let i = 0; i < nodeCount; i++) {
          const size = 0.4 + Math.random() * 0.4;
          const geometry = new THREE.OctahedronGeometry(size, 1);
          const material = new THREE.MeshPhongMaterial({
            color: 0x00bfff,
            emissive: 0x00bfff,
            emissiveIntensity: 0.6,
            shininess: 80,
          });

          const node = new THREE.Mesh(geometry, material);
          node.position.set(
            (Math.random() - 0.5) * 30,
            (Math.random() - 0.5) * 18,
            (Math.random() - 0.5) * 18
          );

          node.userData = {
            pulsePhase: Math.random() * Math.PI * 2,
            pulseSpeed: 0.03 + Math.random() * 0.03,
            originalPosition: node.position.clone(),
            wanderSpeed: 0.002 + Math.random() * 0.003,
            wanderPhase: Math.random() * Math.PI * 2,
          };

          scene.add(node);
          nodes.push(node);
          moodObjects.push(node);
        }

        // Create connections between nearby nodes
        for (let i = 0; i < nodeCount; i++) {
          for (let j = i + 1; j < nodeCount; j++) {
            const distance = nodes[i].position.distanceTo(nodes[j].position);
            if (distance < 12 && Math.random() < 0.3) {
              // 30% chance for nearby nodes
              const connectionGeometry = new THREE.BufferGeometry();
              const positions = new Float32Array(6);
              positions[0] = nodes[i].position.x;
              positions[1] = nodes[i].position.y;
              positions[2] = nodes[i].position.z;
              positions[3] = nodes[j].position.x;
              positions[4] = nodes[j].position.y;
              positions[5] = nodes[j].position.z;

              connectionGeometry.setAttribute(
                "position",
                new THREE.BufferAttribute(positions, 3)
              );

              const connectionMaterial = new THREE.LineBasicMaterial({
                color: 0x1e90ff,
                transparent: true,
                opacity: 0.4,
                linewidth: 2,
              });

              const connection = new THREE.Line(
                connectionGeometry,
                connectionMaterial
              );
              connection.userData = {
                node1: i,
                node2: j,
              };
              scene.add(connection);
              connections.push(connection);
              moodObjects.push(connection);
            }
          }
        }

        // Enhanced data flow particles
        const particleCount = 80;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const targets = new Float32Array(particleCount * 3);
        const progress = new Float32Array(particleCount);
        const speeds = new Float32Array(particleCount);
        const colors = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
          const startNode = nodes[Math.floor(Math.random() * nodes.length)];
          const endNode = nodes[Math.floor(Math.random() * nodes.length)];

          positions[i * 3] = startNode.position.x;
          positions[i * 3 + 1] = startNode.position.y;
          positions[i * 3 + 2] = startNode.position.z;

          targets[i * 3] = endNode.position.x;
          targets[i * 3 + 1] = endNode.position.y;
          targets[i * 3 + 2] = endNode.position.z;

          progress[i] = 0;
          speeds[i] = 0.005 + Math.random() * 0.01;

          // Blue to cyan gradient
          const hue = 180 + Math.random() * 60;
          const color = new THREE.Color(`hsl(${hue}, 90%, 70%)`);
          colors[i * 3] = color.r;
          colors[i * 3 + 1] = color.g;
          colors[i * 3 + 2] = color.b;
        }

        particles.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        particles.setAttribute("target", new THREE.BufferAttribute(targets, 3));
        particles.setAttribute("color", new THREE.BufferAttribute(colors, 3));
        particles.userData = {
          progress: progress,
          speeds: speeds,
        };

        const particleMaterial = new THREE.PointsMaterial({
          color: 0x00ffff,
          size: 0.25,
          vertexColors: true,
          transparent: true,
          opacity: 0.9,
          blending: THREE.AdditiveBlending,
          sizeAttenuation: true,
        });

        const particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);
        particleSystems.push(particleSystem);

        // Add focused lighting
        const directionalLight = new THREE.DirectionalLight(0x1e90ff, 1.2);
        directionalLight.position.set(0, 15, 15);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        moodObjects.push(directionalLight);

        const ambientLight = new THREE.AmbientLight(0x0000ff, 0.3);
        scene.add(ambientLight);
        moodObjects.push(ambientLight);
      }

      // Enhanced animation updates with audio reactivity
      function updateMoodAnimation3D() {
        if (!currentMood) return;

        time++;

        // Get audio data for reactivity
        let audioLevel = 0;
        if (isAudioAnalyzerReady && audioAnalyser && isPlaying) {
          audioAnalyser.getByteFrequencyData(audioData);
          audioLevel =
            audioData.reduce((a, b) => a + b, 0) / audioData.length / 255;
        }

        // Update mood-specific animations with audio reactivity
        moodObjects.forEach((obj, index) => {
          const audioInfluence = 1 + audioLevel * 0.5;

          if (currentMood === "happy") {
            if (obj.material && obj.material.type === "ShaderMaterial") {
              // Update glow material
              obj.material.uniforms.time.value = time * 0.05;
            }

            if (
              obj.geometry &&
              obj.geometry.type === "IcosahedronGeometry" &&
              obj !== moodObjects[0]
            ) {
              // Update orbiting planets with trails
              obj.userData.angle += obj.userData.orbitSpeed * audioInfluence;
              obj.position.x =
                Math.cos(obj.userData.angle) * obj.userData.orbitRadius;
              obj.position.z =
                Math.sin(obj.userData.angle) * obj.userData.orbitRadius;
              obj.rotation.y += 0.02 * audioInfluence;

              // Update trails
              obj.userData.trail.forEach((trail, trailIndex) => {
                const trailAngle = obj.userData.angle - (trailIndex + 1) * 0.1;
                trail.mesh.position.x =
                  Math.cos(trailAngle) * obj.userData.orbitRadius;
                trail.mesh.position.z =
                  Math.sin(trailAngle) * obj.userData.orbitRadius;
                trail.mesh.position.y = obj.position.y;
              });
            }

            if (obj === moodObjects[0]) {
              // Pulsate the sun with audio
              const scale = 1 + Math.sin(time * 0.08) * 0.1 + audioLevel * 0.2;
              obj.scale.set(scale, scale, scale);
            }
          }

          if (currentMood === "sad") {
            if (obj.type === "Points" && obj.geometry.attributes.position) {
              // Update rain particles
              const positions = obj.geometry.attributes.position.array;
              const velocities = obj.geometry.userData.velocities;
              const sizes = obj.geometry.userData.sizes;

              for (let i = 0; i < positions.length; i += 3) {
                positions[i + 1] -= velocities[i / 3] * (1 + audioLevel * 0.3);
                if (positions[i + 1] < -25) {
                  positions[i + 1] = 25;
                  positions[i] = (Math.random() - 0.5) * 60;
                  positions[i + 2] = (Math.random() - 0.5) * 60;
                }
              }

              obj.geometry.attributes.position.needsUpdate = true;
            }

            if (obj.geometry && obj.geometry.type === "SphereGeometry") {
              // Drift and pulse clouds
              obj.position.x += obj.userData.driftSpeed;
              obj.userData.pulsePhase += 0.01;
              const pulse = Math.sin(obj.userData.pulsePhase) * 0.1;
              obj.scale.x = 1 + pulse;
              obj.scale.z = 1 + pulse;
              if (obj.position.x > 30) obj.position.x = -30;
            }

            // Lightning effect
            if (obj.type === "Group" && Math.random() < 0.003) {
              createLightning(obj);
            }
          }

          if (currentMood === "calm") {
            if (obj.type === "Points" && obj.geometry.attributes.position) {
              // Update bubble particles
              const positions = obj.geometry.attributes.position.array;
              const sizes = obj.geometry.userData.sizes;
              const speeds = obj.geometry.userData.speeds;

              for (let i = 0; i < positions.length; i += 3) {
                positions[i + 1] += speeds[i / 3] * (1 + audioLevel * 0.2);
                if (positions[i + 1] > 25) {
                  positions[i + 1] = -25;
                  positions[i] = (Math.random() - 0.5) * 50;
                  positions[i + 2] = (Math.random() - 0.5) * 50;
                }
              }

              obj.geometry.attributes.position.needsUpdate = true;
            }

            if (obj.userData && obj.userData.swaySpeed) {
              // Sway coral
              obj.userData.swayPhase += obj.userData.swaySpeed;
              obj.rotation.z = Math.sin(obj.userData.swayPhase) * 0.1;
            }
          }

          if (currentMood === "energetic") {
            if (obj.geometry && obj.geometry.type === "IcosahedronGeometry") {
              // Rotate and pulsate the core
              obj.rotation.x += 0.03 * audioInfluence;
              obj.rotation.y += 0.04 * audioInfluence;
              const scale = 1 + Math.sin(time * 0.15) * 0.3 + audioLevel * 0.4;
              obj.scale.set(scale, scale, scale);
            }

            if (obj.geometry && obj.geometry.type === "CylinderGeometry") {
              // Pulsate and rotate energy beams
              obj.userData.pulsePhase += 0.15 * audioInfluence;
              const scale = 1 + Math.sin(obj.userData.pulsePhase) * 0.5;
              obj.scale.y = scale;
              obj.rotation.y += 0.01 * audioInfluence;
            }

            if (obj.type === "Points" && obj.geometry.attributes.position) {
              // Update orbiting particles
              const positions = obj.geometry.attributes.position.array;
              const velocities = obj.geometry.attributes.velocity.array;
              const sizes = obj.geometry.attributes.size.array;

              for (let i = 0; i < positions.length; i += 3) {
                // Move particles
                positions[i] += velocities[i] * audioInfluence;
                positions[i + 1] += velocities[i + 1] * audioInfluence;
                positions[i + 2] += velocities[i + 2] * audioInfluence;

                // Apply centripetal force
                const center = new THREE.Vector3(0, 0, 0);
                const particlePos = new THREE.Vector3(
                  positions[i],
                  positions[i + 1],
                  positions[i + 2]
                );
                const toCenter = center.clone().sub(particlePos).normalize();
                const distance = particlePos.distanceTo(center);
                const force = 0.0001 * distance;

                velocities[i] += toCenter.x * force;
                velocities[i + 1] += toCenter.y * force;
                velocities[i + 2] += toCenter.z * force;

                // Size pulsation
                sizes[i / 3] =
                  0.2 + Math.sin(time * 0.1 + i) * 0.1 + audioLevel * 0.2;
              }

              obj.geometry.attributes.position.needsUpdate = true;
              obj.geometry.attributes.size.needsUpdate = true;
            }
          }

          if (currentMood === "romantic") {
            if (obj.geometry && obj.geometry.type === "ExtrudeGeometry") {
              // Rotate and float hearts
              obj.rotation.y += obj.userData.rotationSpeed;
              obj.userData.floatOffset += obj.userData.floatSpeed;
              obj.position.y =
                obj.userData.originalPosition.y +
                Math.sin(obj.userData.floatOffset) * 2;
              obj.position.x =
                obj.userData.originalPosition.x +
                Math.cos(obj.userData.floatOffset * 0.7) * 1;
            }

            if (obj.geometry && obj.geometry.type === "PlaneGeometry") {
              // Float and rotate rose petals with drift
              obj.userData.floatOffset += obj.userData.floatSpeed;
              obj.position.y += Math.sin(obj.userData.floatOffset) * 0.05;
              obj.position.add(obj.userData.drift);
              obj.rotation.z += obj.userData.rotationSpeed;

              // Reset if out of bounds
              if (
                Math.abs(obj.position.x) > 20 ||
                Math.abs(obj.position.y) > 15 ||
                Math.abs(obj.position.z) > 15
              ) {
                obj.position.set(
                  (Math.random() - 0.5) * 10,
                  (Math.random() - 0.5) * 8,
                  (Math.random() - 0.5) * 10
                );
              }
            }
          }

          if (currentMood === "focused") {
            if (
              obj.geometry &&
              (obj.geometry.type === "OctahedronGeometry" ||
                obj.geometry.type === "IcosahedronGeometry")
            ) {
              // Pulsate and wander nodes
              obj.userData.pulsePhase += obj.userData.pulseSpeed;
              obj.userData.wanderPhase += obj.userData.wanderSpeed;

              const scale = 1 + Math.sin(obj.userData.pulsePhase) * 0.3;
              obj.scale.set(scale, scale, scale);

              // Gentle wandering motion
              obj.position.x =
                obj.userData.originalPosition.x +
                Math.sin(obj.userData.wanderPhase) * 1;
              obj.position.y =
                obj.userData.originalPosition.y +
                Math.cos(obj.userData.wanderPhase * 1.3) * 0.7;
              obj.position.z =
                obj.userData.originalPosition.z +
                Math.sin(obj.userData.wanderPhase * 0.7) * 0.8;
            }

            if (obj.type === "Points" && obj.geometry.attributes.position) {
              // Move data flow particles
              const positions = obj.geometry.attributes.position.array;
              const targets = obj.geometry.attributes.target.array;
              const progress = obj.geometry.userData.progress;
              const speeds = obj.geometry.userData.speeds;
              const colors = obj.geometry.attributes.color.array;

              for (let i = 0; i < positions.length / 3; i++) {
                progress[i] += speeds[i] * (1 + audioLevel * 0.5);

                if (progress[i] >= 1) {
                  progress[i] = 0;
                  // Find new random target
                  const nodeIndex = Math.floor(
                    Math.random() * Math.min(40, moodObjects.length)
                  );
                  if (
                    moodObjects[nodeIndex] &&
                    moodObjects[nodeIndex].position
                  ) {
                    const startPos = moodObjects[nodeIndex].position;
                    const endNode =
                      moodObjects[
                        Math.floor(
                          Math.random() * Math.min(40, moodObjects.length)
                        )
                      ];

                    if (endNode && endNode.position) {
                      positions[i * 3] = startPos.x;
                      positions[i * 3 + 1] = startPos.y;
                      positions[i * 3 + 2] = startPos.z;

                      targets[i * 3] = endNode.position.x;
                      targets[i * 3 + 1] = endNode.position.y;
                      targets[i * 3 + 2] = endNode.position.z;
                    }
                  }
                } else {
                  // Interpolate between start and target
                  const startX = positions[i * 3];
                  const startY = positions[i * 3 + 1];
                  const startZ = positions[i * 3 + 2];

                  const targetX = targets[i * 3];
                  const targetY = targets[i * 3 + 1];
                  const targetZ = targets[i * 3 + 2];

                  positions[i * 3] =
                    startX + (targetX - startX) * speeds[i] * 10;
                  positions[i * 3 + 1] =
                    startY + (targetY - startY) * speeds[i] * 10;
                  positions[i * 3 + 2] =
                    startZ + (targetZ - startZ) * speeds[i] * 10;
                }

                // Pulse color based on progress
                const hue = 180 + Math.sin(progress[i] * Math.PI * 2) * 30;
                const color = new THREE.Color(`hsl(${hue}, 90%, 70%)`);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
              }

              obj.geometry.attributes.position.needsUpdate = true;
              obj.geometry.attributes.color.needsUpdate = true;
            }

            // Update connection lines
            if (obj.userData && obj.userData.node1 !== undefined) {
              const node1 = moodObjects[obj.userData.node1];
              const node2 = moodObjects[obj.userData.node2];

              if (node1 && node2) {
                const positions = obj.geometry.attributes.position.array;
                positions[0] = node1.position.x;
                positions[1] = node1.position.y;
                positions[2] = node1.position.z;
                positions[3] = node2.position.x;
                positions[4] = node2.position.y;
                positions[5] = node2.position.z;
                obj.geometry.attributes.position.needsUpdate = true;
              }
            }
          }
        });

        // Update particle systems
        particleSystems.forEach((system) => {
          if (system.geometry.attributes.position) {
            system.geometry.attributes.position.needsUpdate = true;
          }
          if (system.geometry.attributes.color) {
            system.geometry.attributes.color.needsUpdate = true;
          }
          if (system.geometry.attributes.size) {
            system.geometry.attributes.size.needsUpdate = true;
          }
        });
      }

      // Helper function for lightning effect
      function createLightning(lightningGroup) {
        // Clear previous lightning
        while (lightningGroup.children.length > 0) {
          lightningGroup.remove(lightningGroup.children[0]);
        }

        const lightningCount = 3 + Math.floor(Math.random() * 3);

        for (let i = 0; i < lightningCount; i++) {
          const segments = 8;
          const points = [];

          let x = (Math.random() - 0.5) * 40;
          let y = 25;
          let z = (Math.random() - 0.5) * 30;

          points.push(new THREE.Vector3(x, y, z));

          for (let j = 0; j < segments; j++) {
            x += (Math.random() - 0.5) * 8;
            y -= 25 / segments;
            z += (Math.random() - 0.5) * 8;
            points.push(new THREE.Vector3(x, y, z));
          }

          const lightningGeometry = new THREE.BufferGeometry().setFromPoints(
            points
          );
          const lightningMaterial = new THREE.LineBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.9,
          });

          const lightning = new THREE.Line(
            lightningGeometry,
            lightningMaterial
          );
          lightningGroup.add(lightning);

          // Fade out lightning
          setTimeout(() => {
            if (lightningGroup.children.includes(lightning)) {
              lightningGroup.remove(lightning);
            }
          }, 100);
        }
      }

      function animate3D() {
        animationFrame = requestAnimationFrame(animate3D);

        updateMoodAnimation3D();

        if (!currentMood) {
          // Default camera movement when no mood is selected
          camera.position.x = Math.sin(time * 0.003) * 15;
          camera.position.y = Math.cos(time * 0.002) * 8;
          camera.position.z = 35 + Math.sin(time * 0.001) * 5;
        } else {
          // Enhanced mood-specific camera movements
          switch (currentMood) {
            case "happy":
              camera.position.x = Math.sin(time * 0.008) * 18;
              camera.position.y = 6 + Math.cos(time * 0.006) * 4;
              camera.position.z = 28 + Math.sin(time * 0.005) * 6;
              break;
            case "sad":
              camera.position.x = Math.sin(time * 0.003) * 12;
              camera.position.y = 2 + Math.cos(time * 0.002) * 3;
              camera.position.z = 24 + Math.sin(time * 0.002) * 4;
              break;
            case "calm":
              camera.position.x = Math.sin(time * 0.002) * 10;
              camera.position.y = -3 + Math.cos(time * 0.001) * 2;
              camera.position.z = 30 + Math.sin(time * 0.001) * 3;
              break;
            case "energetic":
              camera.position.x = Math.sin(time * 0.015) * 10;
              camera.position.y = Math.cos(time * 0.012) * 6;
              camera.position.z = 24 + Math.sin(time * 0.008) * 8;
              break;
            case "romantic":
              camera.position.x = Math.sin(time * 0.004) * 14;
              camera.position.y = 4 + Math.cos(time * 0.003) * 3;
              camera.position.z = 22 + Math.sin(time * 0.003) * 4;
              break;
            case "focused":
              camera.position.x = Math.sin(time * 0.002) * 12;
              camera.position.y = 1 + Math.cos(time * 0.001) * 2;
              camera.position.z = 26 + Math.sin(time * 0.001) * 3;
              break;
          }
        }

        camera.lookAt(0, 0, 0);
        renderer.render(scene, camera);

        time++;
      }

      // Playlist Functions (unchanged)
      function generateShuffleOrder(playlistLength) {
        const order = Array.from({ length: playlistLength }, (_, i) => i);
        for (let i = order.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [order[i], order[j]] = [order[j], order[i]];
        }
        return order;
      }

      function getNextTrackIndex() {
        if (!currentPlaylist.length) return 0;

        if (isShuffleMode) {
          if (shuffleOrder.length === 0) {
            shuffleOrder = generateShuffleOrder(currentPlaylist.length);
          }

          const currentShuffleIndex = shuffleOrder.indexOf(currentTrackIndex);
          const nextShuffleIndex =
            (currentShuffleIndex + 1) % shuffleOrder.length;
          return shuffleOrder[nextShuffleIndex];
        } else {
          return (currentTrackIndex + 1) % currentPlaylist.length;
        }
      }

      function getPreviousTrackIndex() {
        if (!currentPlaylist.length) return 0;

        if (isShuffleMode) {
          if (shuffleOrder.length === 0) {
            shuffleOrder = generateShuffleOrder(currentPlaylist.length);
          }

          const currentShuffleIndex = shuffleOrder.indexOf(currentTrackIndex);
          const prevShuffleIndex =
            currentShuffleIndex === 0
              ? shuffleOrder.length - 1
              : currentShuffleIndex - 1;
          return shuffleOrder[prevShuffleIndex];
        } else {
          return currentTrackIndex === 0
            ? currentPlaylist.length - 1
            : currentTrackIndex - 1;
        }
      }

      function playTrack(trackIndex) {
        if (
          !currentPlaylist.length ||
          trackIndex < 0 ||
          trackIndex >= currentPlaylist.length
        ) {
          return;
        }

        currentTrackIndex = trackIndex;
        const track = currentPlaylist[currentTrackIndex];

        updateTrackInfo();
        loadAudioForTrack(track);

        if (userInteracted) {
          autoPlayMood();
        }
      }

      function playNext() {
        const nextIndex = getNextTrackIndex();
        playTrack(nextIndex);
      }

      function playPrevious() {
        const prevIndex = getPreviousTrackIndex();
        playTrack(prevIndex);
      }

      function updateTrackInfo() {
        if (!currentPlaylist.length) return;

        const track = currentPlaylist[currentTrackIndex];
        const moodData = moodPlaylists[currentMood];

        document.getElementById("song-title").textContent = track.title;
        document.getElementById("track-info").textContent = `Track ${
          currentTrackIndex + 1
        } of ${currentPlaylist.length} ‚Ä¢ ${moodData.name}`;
      }

      function togglePlaybackMode() {
        isShuffleMode = !isShuffleMode;

        const shuffleBtn = document.getElementById("shuffle-btn");
        const sequentialBtn = document.getElementById("sequential-btn");

        if (isShuffleMode) {
          shuffleBtn.classList.add("active");
          sequentialBtn.classList.remove("active");
          shuffleOrder = generateShuffleOrder(currentPlaylist.length);
        } else {
          shuffleBtn.classList.remove("active");
          sequentialBtn.classList.add("active");
          shuffleOrder = [];
        }
      }

      // AI Chat Functions (unchanged)
      function addMessage(
        content,
        isUser = false,
        hasSuggestion = false,
        suggestedMood = null
      ) {
        const messagesContainer = document.getElementById("chat-messages");
        const messageDiv = document.createElement("div");
        messageDiv.className = `message ${isUser ? "user" : "ai"}`;

        const headerDiv = document.createElement("div");
        headerDiv.className = "message-header";
        headerDiv.textContent = isUser ? "You" : "MoodBot";

        const contentDiv = document.createElement("div");
        contentDiv.className = "message-content";
        contentDiv.textContent = content;

        messageDiv.appendChild(headerDiv);
        messageDiv.appendChild(contentDiv);

        if (hasSuggestion && suggestedMood) {
          const suggestionDiv = document.createElement("div");
          suggestionDiv.className = "mood-suggestion";
          suggestionDiv.onclick = () => selectMoodFromChat(suggestedMood);

          const suggestionText = document.createElement("div");
          suggestionText.className = "mood-suggestion-text";
          suggestionText.textContent = `üéµ Switch to ${
            suggestedMood.charAt(0).toUpperCase() + suggestedMood.slice(1)
          } mood`;

          suggestionDiv.appendChild(suggestionText);
          messageDiv.appendChild(suggestionDiv);
        }

        messagesContainer.appendChild(messageDiv);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;

        chatHistory.push({
          content: content,
          isUser: isUser,
          timestamp: Date.now(),
          suggestedMood: suggestedMood,
        });
      }

      function showTypingIndicator() {
        const typingIndicator = document.getElementById("typing-indicator");
        typingIndicator.style.display = "flex";
        isTyping = true;

        const messagesContainer = document.getElementById("chat-messages");
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }

      function hideTypingIndicator() {
        const typingIndicator = document.getElementById("typing-indicator");
        typingIndicator.style.display = "none";
        isTyping = false;
      }

      function analyzeMoodFromText(text) {
        const lowerText = text.toLowerCase();
        let detectedMood = null;
        let maxScore = 0;
        let matchedKeywords = [];

        const musicTerms = [
          "music",
          "song",
          "track",
          "tune",
          "sound",
          "audio",
          "play",
          "listen",
          "hear",
        ];
        const hasMusicRequest = musicTerms.some((term) =>
          lowerText.includes(term)
        );

        Object.entries(moodKeywords).forEach(([mood, data]) => {
          const score = data.keywords.reduce((count, keyword) => {
            if (lowerText.includes(keyword)) {
              matchedKeywords.push(keyword);
              return count + 1;
            }
            return count;
          }, 0);

          if (score > maxScore) {
            maxScore = score;
            detectedMood = mood;
          }
        });

        const confidenceMultiplier = hasMusicRequest ? 1.5 : 1;
        const adjustedScore = maxScore * confidenceMultiplier;

        return {
          mood: detectedMood,
          confidence: adjustedScore > 0 ? Math.min(adjustedScore * 0.25, 1) : 0,
          keywords: matchedKeywords,
          hasMusicRequest: hasMusicRequest,
        };
      }

      function generateAIResponse(userMessage) {
        const analysis = analyzeMoodFromText(userMessage);
        let response = "";
        let suggestedMood = null;

        const confidenceThreshold = analysis.hasMusicRequest ? 0.2 : 0.3;

        if (analysis.confidence > confidenceThreshold && analysis.mood) {
          const moodData = moodKeywords[analysis.mood];
          response =
            moodData.responses[
              Math.floor(Math.random() * moodData.responses.length)
            ];
          suggestedMood = analysis.mood;
        } else if (analysis.confidence > 0.1 && analysis.mood) {
          response = `I'm picking up on some ${
            analysis.mood
          } vibes from what you're saying. ${
            followUpQuestions[analysis.mood][
              Math.floor(
                Math.random() * followUpQuestions[analysis.mood].length
              )
            ]
          }`;
        } else if (analysis.hasMusicRequest) {
          response =
            "I can tell you're looking for some music! To give you the perfect soundtrack, could you tell me more about your current mood or what kind of atmosphere you're going for?";
        } else {
          const responses = [
            "I'd love to understand your mood better. " +
              conversationStarters[
                Math.floor(Math.random() * conversationStarters.length)
              ],
            "Tell me more about how you're feeling. Are you looking for something upbeat, calming, or perhaps energizing?",
            "I'm here to help you find the perfect music for your state of mind. What's your emotional landscape like right now?",
            "Every mood deserves the right soundtrack. Help me understand what you're going through so I can curate something special for you.",
          ];
          response = responses[Math.floor(Math.random() * responses.length)];
        }

        return { response: response, suggestedMood: suggestedMood };
      }

      function sendChatMessage() {
        const chatInput = document.getElementById("chat-input");
        const message = chatInput.value.trim();

        if (!message || isTyping) return;

        addMessage(message, true);
        chatInput.value = "";
        autoResizeTextarea(chatInput);

        showTypingIndicator();

        setTimeout(() => {
          hideTypingIndicator();
          const aiResponse = generateAIResponse(message);
          addMessage(
            aiResponse.response,
            false,
            aiResponse.suggestedMood !== null,
            aiResponse.suggestedMood
          );
        }, 1000 + Math.random() * 1000);
      }

      function selectMoodFromChat(mood, instantPlay = false) {
        selectMood(mood);

        if (instantPlay) {
          setTimeout(() => {
            if (!isPlaying) {
              togglePlayPause();
            }
          }, 500);
        }

        setTimeout(
          () => {
            const confirmationMessages = instantPlay
              ? [
                  `üéµ Perfect! Now playing ${mood} playlist with ${
                    currentPlaylist.length
                  } tracks in ${
                    isShuffleMode ? "shuffle" : "sequential"
                  } mode. Enjoy!`,
                  `üé∂ Excellent! Your ${mood} playlist is now live with matching visuals. Let the vibes flow!`,
                  `‚ú® Amazing! ${
                    mood.charAt(0).toUpperCase() + mood.slice(1)
                  } playlist activated with instant music playback!`,
                ]
              : [
                  `Perfect! I've loaded the ${mood} playlist with ${currentPlaylist.length} tracks. Click play when you're ready!`,
                  `Great choice! ${
                    mood.charAt(0).toUpperCase() + mood.slice(1)
                  } playlist is ready with matching visuals. Hit play to start!`,
                  `Excellent! Your ${mood} playlist is set up in ${
                    isShuffleMode ? "shuffle" : "sequential"
                  } mode. Ready when you are!`,
                ];

            const confirmation =
              confirmationMessages[
                Math.floor(Math.random() * confirmationMessages.length)
              ];
            addMessage(confirmation, false);
          },
          instantPlay ? 1000 : 500
        );
      }

      function autoResizeTextarea(textarea) {
        textarea.style.height = "auto";
        textarea.style.height = Math.min(textarea.scrollHeight, 100) + "px";
      }

      function initChatEventListeners() {
        const chatInput = document.getElementById("chat-input");
        const sendBtn = document.getElementById("send-btn");

        chatInput.addEventListener("input", (e) => {
          autoResizeTextarea(e.target);
        });

        sendBtn.addEventListener("click", sendChatMessage);

        chatInput.addEventListener("keypress", (e) => {
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            sendChatMessage();
          }
        });

        chatInput.addEventListener("input", () => {
          sendBtn.disabled = isTyping;
        });
      }

      // Audio Functions (unchanged)
      function initializeAudio() {
        if (!audioContext) {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
        }
      }

      function loadAudioForTrack(track) {
        if (currentAudio) {
          currentAudio.pause();
          currentAudio.currentTime = 0;
          currentAudio.removeEventListener("loadstart", handleLoadStart);
          currentAudio.removeEventListener(
            "canplaythrough",
            handleCanPlayThrough
          );
          currentAudio.removeEventListener("error", handleAudioError);
          currentAudio.removeEventListener("timeupdate", updateProgressBar);
          currentAudio.removeEventListener("ended", handleTrackEnded);
          currentAudio = null;
        }

        if (progressInterval) {
          clearInterval(progressInterval);
          progressInterval = null;
        }

        if (track.file) {
          try {
            currentAudio = new Audio(track.file);
            currentAudio.loop = false;
            currentAudio.volume = 0.7;
            currentAudio.preload = "auto";

            currentAudio.addEventListener("loadstart", handleLoadStart);
            currentAudio.addEventListener(
              "canplaythrough",
              handleCanPlayThrough
            );
            currentAudio.addEventListener("error", handleAudioError);
            currentAudio.addEventListener("timeupdate", updateProgressBar);
            currentAudio.addEventListener("ended", handleTrackEnded);

            // Connect to audio analyzer for visualization
            if (isAudioAnalyzerReady) {
              connectAudioToAnalyzer(currentAudio);
            }

            currentAudio.load();
          } catch (error) {
            console.error(`Failed to create audio for ${track.title}:`, error);
            fallbackToSimulation();
          }
        } else {
          fallbackToSimulation();
        }
      }

      function handleLoadStart() {
        document.getElementById("song-title").style.color = "#a1a8c9";
      }

      function handleCanPlayThrough() {
        document.getElementById("song-title").style.color = "#fff";
      }

      function handleAudioError(e) {
        console.error("Audio loading error:", e);
        fallbackToSimulation();
      }

      function handleTrackEnded() {
        console.log("Track ended, playing next...");
        playNext();
      }

      function fallbackToSimulation() {
        simulatePlayback();
      }

      function simulatePlayback() {
        isPlaying = true;
        document.getElementById("play-btn").textContent = "‚è∏";

        let progress = 0;
        const trackDuration = 180;
        const increment = 100 / (trackDuration * 10);

        progressInterval = setInterval(() => {
          if (!isPlaying) {
            clearInterval(progressInterval);
            progressInterval = null;
            return;
          }

          progress += increment;
          if (progress >= 100) {
            progress = 100;
            setTimeout(() => {
              if (isPlaying) {
                playNext();
              }
            }, 500);
          }

          document.getElementById("progress-bar").style.width = `${progress}%`;
        }, 100);
      }

      function updateProgressBar() {
        if (
          currentAudio &&
          currentAudio.duration &&
          !isNaN(currentAudio.duration)
        ) {
          const progress =
            (currentAudio.currentTime / currentAudio.duration) * 100;
          document.getElementById("progress-bar").style.width = `${progress}%`;
        }
      }

      function autoPlayMood() {
        if (!userInteracted) {
          return;
        }

        initializeAudio();

        if (!currentAudio) {
          simulatePlayback();
          return;
        }

        setTimeout(() => {
          if (currentAudio && currentAudio.readyState >= 3) {
            playAudio();
          } else if (currentAudio) {
            currentAudio.addEventListener("canplaythrough", playAudio, {
              once: true,
            });
            setTimeout(() => {
              if (!isPlaying) {
                fallbackToSimulation();
              }
            }, 3000);
          } else {
            fallbackToSimulation();
          }
        }, 100);
      }

      function playAudio() {
        if (!currentAudio) {
          fallbackToSimulation();
          return;
        }

        isPlaying = true;
        document.getElementById("play-btn").textContent = "‚è∏";

        if (audioContext && audioContext.state === "suspended") {
          audioContext.resume();
        }

        currentAudio
          .play()
          .then(() => {
            console.log(
              `Successfully playing: ${currentPlaylist[currentTrackIndex].title}`
            );
          })
          .catch((error) => {
            console.error("Audio play failed:", error);
            fallbackToSimulation();
          });
      }

      // Mood Selection (unchanged)
      function selectMood(mood) {
        userInteracted = true;

        if (currentMood) {
          clearMoodObjects();
        }

        currentMood = mood;
        const moodData = moodPlaylists[mood];

        currentPlaylist = [...moodData.tracks];
        currentTrackIndex = 0;

        if (isShuffleMode) {
          shuffleOrder = generateShuffleOrder(currentPlaylist.length);
          currentTrackIndex = shuffleOrder[0];
        }

        document.querySelectorAll(".mood-btn").forEach((btn) => {
          btn.classList.remove("active");
        });
        document.querySelector(`[data-mood="${mood}"]`).classList.add("active");

        document.getElementById("current-mood-display").textContent =
          mood.charAt(0).toUpperCase() + mood.slice(1);
        document.getElementById("mood-indicator").textContent = `Mood: ${
          mood.charAt(0).toUpperCase() + mood.slice(1)
        }`;

        updateTrackInfo();

        // Create 3D animation for selected mood
        switch (mood) {
          case "happy":
            createHappyAnimation3D();
            break;
          case "sad":
            createSadAnimation3D();
            break;
          case "calm":
            createCalmAnimation3D();
            break;
          case "energetic":
            createEnergeticAnimation3D();
            break;
          case "romantic":
            createRomanticAnimation3D();
            break;
          case "focused":
            createFocusedAnimation3D();
            break;
        }

        const firstTrack = currentPlaylist[currentTrackIndex];
        loadAudioForTrack(firstTrack);
        autoPlayMood();
      }

      function analyzeText() {
        const text = document.getElementById("mood-text").value.trim();
        if (!text) return;

        userInteracted = true;
        const analysis = analyzeMoodFromText(text);
        let detectedMood = analysis.mood || "calm";
        selectMood(detectedMood);
      }

      function togglePlayPause() {
        userInteracted = true;

        if (!currentMood) {
          selectMood("happy");
          return;
        }

        if (isPlaying) {
          pauseAudio();
        } else {
          resumeAudio();
        }
      }

      function pauseAudio() {
        isPlaying = false;
        document.getElementById("play-btn").textContent = "‚ñ∂";

        if (progressInterval) {
          clearInterval(progressInterval);
          progressInterval = null;
        }

        if (currentAudio) {
          currentAudio.pause();
        }
      }

      function resumeAudio() {
        if (currentAudio && currentAudio.readyState >= 3) {
          playAudio();
        } else if (currentAudio) {
          currentAudio.addEventListener("canplaythrough", playAudio, {
            once: true,
          });
        } else {
          simulatePlayback();
        }
      }

      // Fullscreen functionality (unchanged)
      function toggleFullscreen() {
        const visualizationContainer = document.getElementById(
          "visualization-container"
        );
        const fullscreenBtn = document.getElementById("fullscreen-btn");

        if (!isFullscreen) {
          if (visualizationContainer.requestFullscreen) {
            visualizationContainer.requestFullscreen();
          } else if (visualizationContainer.webkitRequestFullscreen) {
            visualizationContainer.webkitRequestFullscreen();
          } else if (visualizationContainer.mozRequestFullScreen) {
            visualizationContainer.mozRequestFullScreen();
          } else if (visualizationContainer.msRequestFullscreen) {
            visualizationContainer.msRequestFullscreen();
          } else {
            visualizationContainer.classList.add("fullscreen");
            isFullscreen = true;
            fullscreenBtn.innerHTML = "‚õ∂";
            fullscreenBtn.title = "Exit Fullscreen";
            handleResize();
          }
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          } else {
            visualizationContainer.classList.remove("fullscreen");
            isFullscreen = false;
            fullscreenBtn.innerHTML = "‚õ∂";
            fullscreenBtn.title = "Toggle Fullscreen";
            handleResize();
          }
        }
      }

      function handleFullscreenChange() {
        const visualizationContainer = document.getElementById(
          "visualization-container"
        );
        const fullscreenBtn = document.getElementById("fullscreen-btn");

        const isCurrentlyFullscreen = !!(
          document.fullscreenElement ||
          document.webkitFullscreenElement ||
          document.mozFullScreenElement ||
          document.msFullscreenElement
        );

        if (isCurrentlyFullscreen && !isFullscreen) {
          isFullscreen = true;
          visualizationContainer.classList.add("fullscreen");
          fullscreenBtn.innerHTML = "‚õ∑";
          fullscreenBtn.title = "Exit Fullscreen";
          handleResize();
        } else if (!isCurrentlyFullscreen && isFullscreen) {
          isFullscreen = false;
          visualizationContainer.classList.remove("fullscreen");
          fullscreenBtn.innerHTML = "‚õ∂";
          fullscreenBtn.title = "Toggle Fullscreen";
          handleResize();
        }
      }

      // Window resize handler
      function handleResize() {
        const container = document.getElementById("visualization-container");
        const width = container.clientWidth;
        const height = container.clientHeight;

        if (camera && renderer) {
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
          renderer.setSize(width, height);
        }
      }

      // Event Listeners (unchanged)
      function initEventListeners() {
        initChatEventListeners();

        document.querySelectorAll(".mood-btn").forEach((btn) => {
          btn.addEventListener("click", () => {
            const mood = btn.getAttribute("data-mood");
            selectMood(mood);
          });
        });

        document
          .getElementById("analyze-btn")
          .addEventListener("click", analyzeText);
        document
          .getElementById("play-btn")
          .addEventListener("click", togglePlayPause);

        // Shuffle and Sequential buttons
        document.getElementById("shuffle-btn").addEventListener("click", () => {
          if (!isShuffleMode) {
            togglePlaybackMode();
          }
        });

        document
          .getElementById("sequential-btn")
          .addEventListener("click", () => {
            if (isShuffleMode) {
              togglePlaybackMode();
            }
          });

        document
          .getElementById("prev-btn")
          .addEventListener("click", playPrevious);
        document.getElementById("next-btn").addEventListener("click", playNext);

        // Fullscreen button
        document
          .getElementById("fullscreen-btn")
          .addEventListener("click", toggleFullscreen);

        // Fullscreen change events
        document.addEventListener("fullscreenchange", handleFullscreenChange);
        document.addEventListener(
          "webkitfullscreenchange",
          handleFullscreenChange
        );
        document.addEventListener(
          "mozfullscreenchange",
          handleFullscreenChange
        );
        document.addEventListener("msfullscreenchange", handleFullscreenChange);

        // Progress bar click to seek
        document
          .querySelector(".progress-container")
          .addEventListener("click", (e) => {
            if (currentAudio && currentAudio.duration) {
              const rect = e.target.getBoundingClientRect();
              const clickX = e.clientX - rect.left;
              const percentage = clickX / rect.width;
              const newTime = percentage * currentAudio.duration;
              currentAudio.currentTime = newTime;
            }
          });

        // Volume control with mouse wheel on progress bar
        document
          .querySelector(".progress-container")
          .addEventListener("wheel", (e) => {
            e.preventDefault();
            if (currentAudio) {
              const volumeChange = e.deltaY > 0 ? -0.1 : 0.1;
              currentAudio.volume = Math.max(
                0,
                Math.min(1, currentAudio.volume + volumeChange)
              );

              const progressContainer = e.target.closest(".progress-container");
              progressContainer.style.opacity = currentAudio.volume;
              setTimeout(() => {
                progressContainer.style.opacity = "1";
              }, 200);
            }
          });

        // Keyboard shortcuts
        document.addEventListener("keydown", (e) => {
          if (e.target.tagName === "TEXTAREA") return;

          switch (e.code) {
            case "Space":
              e.preventDefault();
              togglePlayPause();
              break;
            case "KeyF":
              e.preventDefault();
              toggleFullscreen();
              break;
            case "ArrowUp":
              e.preventDefault();
              if (currentAudio) {
                currentAudio.volume = Math.min(1, currentAudio.volume + 0.1);
              }
              break;
            case "ArrowDown":
              e.preventDefault();
              if (currentAudio) {
                currentAudio.volume = Math.max(0, currentAudio.volume - 0.1);
              }
              break;
            case "ArrowLeft":
              e.preventDefault();
              if (currentAudio) {
                currentAudio.currentTime = Math.max(
                  0,
                  currentAudio.currentTime - 10
                );
              } else {
                playPrevious();
              }
              break;
            case "ArrowRight":
              e.preventDefault();
              if (currentAudio) {
                currentAudio.currentTime = Math.min(
                  currentAudio.duration || 0,
                  currentAudio.currentTime + 10
                );
              } else {
                playNext();
              }
              break;
            case "KeyN":
              e.preventDefault();
              playNext();
              break;
            case "KeyP":
              e.preventDefault();
              playPrevious();
              break;
            case "KeyS":
              e.preventDefault();
              togglePlaybackMode();
              break;
          }
        });

        document
          .getElementById("mood-text")
          .addEventListener("keypress", (e) => {
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              analyzeText();
            }
          });

        window.addEventListener("resize", handleResize);
      }

      // Initialize everything when page loads
      document.addEventListener("DOMContentLoaded", () => {
        initThree();
        initEventListeners();
        console.log(
          "MoodTune with UPGRADED 3D animations and all original functionality initialized!"
        );
        console.log(
          "New Features: Enhanced particle systems, Audio-reactive visuals, Complex geometries, Improved lighting"
        );
        console.log(
          "Keyboard shortcuts: Space (play/pause), N (next), P (previous), S (toggle shuffle), F (fullscreen)"
        );
      });
    </script>
  </body>
</html>
