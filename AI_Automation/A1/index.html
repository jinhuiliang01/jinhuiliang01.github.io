<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MoodTune - Emotion-Based Music Player</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sentiment/5.0.2/sentiment.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Poppins", sans-serif;
      }

      body {
        background: linear-gradient(
          135deg,
          #0a0a15 0%,
          #1a1a2e 50%,
          #16213e 100%
        );
        color: #fff;
        min-height: 100vh;
        overflow-x: hidden;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
      }

      header {
        text-align: center;
        padding: 30px 0;
        z-index: 10;
        position: relative;
      }

      h1 {
        font-size: 4rem;
        background: linear-gradient(45deg, #e94584, #0ff0fc, #ffd700, #ff6b6b);
        background-size: 400% 400%;
        background-clip: text;
        -webkit-background-clip: text;
        color: transparent;
        -webkit-text-fill-color: transparent;
        margin-bottom: 15px;
        text-shadow: 0 0 30px rgba(233, 69, 132, 0.5);
        animation: gradientShift 4s ease-in-out infinite;
        letter-spacing: 2px;
      }

      @keyframes gradientShift {
        0%,
        100% {
          background-position: 0% 50%;
        }
        50% {
          background-position: 100% 50%;
        }
      }

      .tagline {
        font-size: 1.4rem;
        color: #a1a8c9;
        margin-bottom: 40px;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      }

      .main-content {
        display: flex;
        flex: 1;
        gap: 40px;
        z-index: 10;
        margin-bottom: 30px;
      }

      .left-panel {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .ai-chat {
        background: rgba(255, 255, 255, 0.08);
        border-radius: 25px;
        padding: 30px;
        backdrop-filter: blur(15px);
        box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
        min-height: 400px;
        display: flex;
        flex-direction: column;
      }

      .mood-selector {
        background: rgba(255, 255, 255, 0.08);
        border-radius: 25px;
        padding: 30px;
        backdrop-filter: blur(15px);
        box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .visualization {
        flex: 2.5;
        border-radius: 25px;
        overflow: hidden;
        position: relative;
        box-shadow: 0 15px 60px rgba(0, 0, 0, 0.4);
        min-height: 600px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .section-title {
        font-size: 1.6rem;
        margin-bottom: 25px;
        color: #6e88ff;
        text-align: center;
        text-shadow: 0 2px 10px rgba(110, 136, 255, 0.3);
      }

      .chat-messages {
        flex: 1;
        overflow-y: auto;
        margin-bottom: 20px;
        padding-right: 10px;
        max-height: 300px;
      }

      .message {
        margin-bottom: 15px;
        padding: 12px 18px;
        border-radius: 16px;
        max-width: 85%;
        animation: fadeInUp 0.3s ease;
      }

      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .message.ai {
        background: linear-gradient(
          135deg,
          rgba(110, 136, 255, 0.2),
          rgba(110, 136, 255, 0.1)
        );
        border-left: 3px solid #6e88ff;
        align-self: flex-start;
      }

      .message.user {
        background: linear-gradient(
          135deg,
          rgba(255, 107, 107, 0.2),
          rgba(255, 107, 107, 0.1)
        );
        border-left: 3px solid #ff6b6b;
        margin-left: auto;
        align-self: flex-end;
      }

      .message-header {
        font-size: 0.85rem;
        color: #a1a8c9;
        margin-bottom: 5px;
        font-weight: 500;
      }

      .message-content {
        line-height: 1.4;
        color: #fff;
      }

      .chat-input {
        display: flex;
        gap: 12px;
        align-items: flex-end;
      }

      .chat-input textarea {
        flex: 1;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 16px;
        padding: 12px 16px;
        color: #fff;
        font-size: 0.95rem;
        resize: none;
        min-height: 45px;
        max-height: 100px;
        transition: all 0.3s ease;
      }

      .chat-input textarea::placeholder {
        color: #a1a8c9;
      }

      .chat-input textarea:focus {
        outline: none;
        border: 2px solid #6e88ff;
        box-shadow: 0 0 15px rgba(110, 136, 255, 0.2);
        background: rgba(255, 255, 255, 0.12);
      }

      .send-btn {
        background: linear-gradient(135deg, #6e88ff, #8b5aff);
        border: none;
        color: white;
        width: 45px;
        height: 45px;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        font-size: 1.2rem;
        flex-shrink: 0;
      }

      .send-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 5px 15px rgba(110, 136, 255, 0.4);
      }

      .typing-indicator {
        display: none;
        align-items: center;
        gap: 8px;
        padding: 12px 18px;
        background: linear-gradient(
          135deg,
          rgba(110, 136, 255, 0.15),
          rgba(110, 136, 255, 0.08)
        );
        border-radius: 16px;
        border-left: 3px solid #6e88ff;
        max-width: 85%;
        margin-bottom: 15px;
      }

      .typing-dots {
        display: flex;
        gap: 4px;
      }

      .typing-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #6e88ff;
        animation: typingBounce 1.4s infinite ease-in-out;
      }

      .typing-dot:nth-child(2) {
        animation-delay: 0.2s;
      }

      .typing-dot:nth-child(3) {
        animation-delay: 0.4s;
      }

      @keyframes typingBounce {
        0%,
        80%,
        100% {
          transform: scale(0);
        }
        40% {
          transform: scale(1);
        }
      }

      .mood-suggestion {
        background: linear-gradient(
          135deg,
          rgba(255, 215, 0, 0.2),
          rgba(255, 215, 0, 0.1)
        );
        border: 2px solid rgba(255, 215, 0, 0.3);
        border-radius: 12px;
        padding: 12px;
        margin-top: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .mood-suggestion:hover {
        background: linear-gradient(
          135deg,
          rgba(255, 215, 0, 0.3),
          rgba(255, 215, 0, 0.15)
        );
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(255, 215, 0, 0.2);
      }

      .mood-suggestion-text {
        font-weight: 500;
        color: #ffd700;
      }

      .mood-buttons {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 18px;
        margin-bottom: 35px;
      }

      .mood-btn {
        padding: 18px;
        border: none;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.12);
        color: #fff;
        font-size: 1.1rem;
        cursor: pointer;
        transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        position: relative;
        overflow: hidden;
      }

      .mood-btn:hover {
        transform: translateY(-5px) scale(1.05);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
      }

      .mood-btn.active {
        transform: translateY(-5px) scale(1.05);
        box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5);
        border: 2px solid rgba(255, 255, 255, 0.4);
      }

      .mood-btn.happy {
        background: linear-gradient(135deg, #ff9a9e, #fad0c4, #ffd89b);
        color: #333;
        box-shadow: 0 8px 25px rgba(255, 154, 158, 0.4);
      }
      .mood-btn.sad {
        background: linear-gradient(135deg, #4facfe, #00f2fe, #667eea);
        box-shadow: 0 8px 25px rgba(79, 172, 254, 0.4);
      }
      .mood-btn.calm {
        background: linear-gradient(135deg, #6a11cb, #2575fc, #43cea2);
        box-shadow: 0 8px 25px rgba(106, 17, 203, 0.4);
      }
      .mood-btn.energetic {
        background: linear-gradient(135deg, #f83600, #f9d423, #ff6b6b);
        color: #333;
        box-shadow: 0 8px 25px rgba(248, 54, 0, 0.4);
      }
      .mood-btn.romantic {
        background: linear-gradient(135deg, #ff057c, #8d0b93, #e94584);
        box-shadow: 0 8px 25px rgba(255, 5, 124, 0.4);
      }
      .mood-btn.focused {
        background: linear-gradient(135deg, #0ba360, #3cba92, #20bf6b);
        box-shadow: 0 8px 25px rgba(11, 163, 96, 0.4);
      }

      .text-input {
        margin-top: 30px;
      }

      textarea {
        width: 100%;
        height: 130px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 16px;
        padding: 18px;
        color: #fff;
        font-size: 1rem;
        margin-bottom: 18px;
        resize: none;
        transition: all 0.3s ease;
      }

      textarea::placeholder {
        color: #a1a8c9;
      }

      textarea:focus {
        outline: none;
        border: 2px solid #6e88ff;
        box-shadow: 0 0 20px rgba(110, 136, 255, 0.3);
        background: rgba(255, 255, 255, 0.12);
      }

      .analyze-btn {
        width: 100%;
        padding: 18px;
        border: none;
        border-radius: 16px;
        background: linear-gradient(135deg, #ff6b6b, #ff8e53, #ffa726);
        color: white;
        font-size: 1.1rem;
        cursor: pointer;
        transition: all 0.4s ease;
        box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);
      }

      .analyze-btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 12px 35px rgba(255, 107, 107, 0.5);
      }

      .player-controls {
        background: rgba(255, 255, 255, 0.08);
        border-radius: 25px;
        padding: 30px;
        margin-top: 30px;
        backdrop-filter: blur(15px);
        box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
        z-index: 10;
      }

      .song-info {
        display: flex;
        align-items: center;
        gap: 20px;
        margin-bottom: 25px;
      }

      .album-art {
        width: 90px;
        height: 90px;
        border-radius: 16px;
        background: linear-gradient(135deg, #8e2de2, #4a00e0);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2.2rem;
        box-shadow: 0 8px 25px rgba(142, 45, 226, 0.4);
        animation: pulse 2s ease-in-out infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      .song-details {
        flex: 1;
      }

      .song-title {
        font-size: 1.3rem;
        margin-bottom: 8px;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      }

      .mood-indicator {
        font-size: 1rem;
        color: #a1a8c9;
        margin-bottom: 8px;
      }

      .track-info {
        font-size: 0.9rem;
        color: #ffd700;
        text-shadow: 0 1px 5px rgba(255, 215, 0, 0.3);
      }

      .progress-container {
        width: 100%;
        height: 8px;
        background: rgba(255, 255, 255, 0.12);
        border-radius: 4px;
        margin: 20px 0;
        cursor: pointer;
        position: relative;
        overflow: hidden;
      }

      .progress-bar {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #6e88ff, #ff6b6b, #ffd700);
        border-radius: 4px;
        transition: width 0.1s linear;
        box-shadow: 0 0 10px rgba(110, 136, 255, 0.5);
      }

      .controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 25px;
      }

      .control-btn {
        background: none;
        border: none;
        color: #fff;
        font-size: 1.6rem;
        cursor: pointer;
        padding: 12px;
        transition: all 0.3s ease;
        border-radius: 50%;
      }

      .control-btn:hover {
        color: #6e88ff;
        transform: scale(1.2);
        background: rgba(110, 136, 255, 0.2);
      }

      .play-btn {
        background: linear-gradient(135deg, #6e88ff, #ff6b6b);
        width: 70px;
        height: 70px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2rem;
        box-shadow: 0 8px 30px rgba(110, 136, 255, 0.5);
        transition: all 0.3s ease;
      }

      .play-btn:hover {
        transform: scale(1.1);
        box-shadow: 0 12px 40px rgba(110, 136, 255, 0.6);
      }

      /* New styles for shuffle and sequential buttons */
      .mode-btn {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #fff;
        padding: 10px 16px;
        border-radius: 20px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 0.9rem;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .mode-btn:hover {
        background: rgba(110, 136, 255, 0.3);
        border-color: #6e88ff;
        transform: translateY(-2px);
      }

      .mode-btn.active {
        background: rgba(110, 136, 255, 0.5);
        border-color: #6e88ff;
        box-shadow: 0 4px 15px rgba(110, 136, 255, 0.3);
      }

      #three-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      .mood-display {
        position: absolute;
        bottom: 25px;
        right: 25px;
        background: rgba(0, 0, 0, 0.6);
        padding: 15px 25px;
        border-radius: 25px;
        font-size: 1.3rem;
        z-index: 11;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .fullscreen-btn {
        position: absolute;
        bottom: 25px;
        left: 25px;
        background: rgba(0, 0, 0, 0.6);
        border: none;
        color: #fff;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        font-size: 1.4rem;
        cursor: pointer;
        transition: all 0.3s ease;
        z-index: 11;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .fullscreen-btn:hover {
        background: rgba(110, 136, 255, 0.8);
        transform: scale(1.1);
        box-shadow: 0 8px 25px rgba(110, 136, 255, 0.5);
      }

      .visualization.fullscreen {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        z-index: 9999 !important;
        border-radius: 0 !important;
      }

      .mood-text {
        color: #ff6b6b;
        font-weight: bold;
        text-shadow: 0 2px 10px rgba(255, 107, 107, 0.5);
      }

      footer {
        text-align: center;
        padding: 30px 0;
        color: #a1a8c9;
        font-size: 1rem;
        z-index: 10;
      }

      @media (max-width: 1200px) {
        .main-content {
          flex-direction: column;
        }
        .left-panel {
          flex-direction: row;
        }
        .ai-chat {
          min-height: 350px;
        }
        h1 {
          font-size: 3rem;
        }
      }

      @media (max-width: 800px) {
        .left-panel {
          flex-direction: column;
        }
        .controls {
          flex-wrap: wrap;
          gap: 10px;
          justify-content: center;
        }
        .mode-btn {
          font-size: 0.8rem;
          padding: 8px 12px;
        }
      }

      .chat-messages::-webkit-scrollbar {
        width: 6px;
      }
      .chat-messages::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 3px;
      }
      .chat-messages::-webkit-scrollbar-thumb {
        background: rgba(110, 136, 255, 0.4);
        border-radius: 3px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>MoodTune</h1>
        <p class="tagline">Your emotion-based music experience</p>
      </header>

      <div class="main-content">
        <div class="left-panel">
          <div class="ai-chat">
            <h2 class="section-title">Chat with MoodBot</h2>
            <div class="chat-messages" id="chat-messages">
              <div class="message ai">
                <div class="message-header">MoodBot</div>
                <div class="message-content">
                  Hello! I'm here to help you find the perfect music for your
                  mood. How are you feeling today? Tell me what's on your mind.
                </div>
              </div>
            </div>
            <div class="typing-indicator" id="typing-indicator">
              <div class="message-header">MoodBot is thinking...</div>
              <div class="typing-dots">
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
              </div>
            </div>
            <div class="chat-input">
              <textarea
                id="chat-input"
                placeholder="Tell me how you're feeling..."
                rows="1"
              ></textarea>
              <button class="send-btn" id="send-btn">‚û§</button>
            </div>
          </div>

          <div class="mood-selector">
            <h2 class="section-title">Quick Mood Select</h2>
            <div class="mood-buttons">
              <button class="mood-btn happy" data-mood="happy">üòä Happy</button>
              <button class="mood-btn sad" data-mood="sad">üò¢ Sad</button>
              <button class="mood-btn calm" data-mood="calm">üòå Calm</button>
              <button class="mood-btn energetic" data-mood="energetic">
                ‚ö° Energetic
              </button>
              <button class="mood-btn romantic" data-mood="romantic">
                ‚ù§Ô∏è Romantic
              </button>
              <button class="mood-btn focused" data-mood="focused">
                üéØ Focused
              </button>
            </div>

            <div class="text-input">
              <h2 class="section-title">Text Analysis</h2>
              <textarea
                id="mood-text"
                placeholder="Type how you're feeling today..."
              ></textarea>
              <button class="analyze-btn" id="analyze-btn">
                Analyze My Text
              </button>
            </div>
          </div>
        </div>

        <div class="visualization" id="visualization-container">
          <canvas id="three-canvas"></canvas>
          <div class="mood-display">
            Current Mood:
            <span class="mood-text" id="current-mood-display">None</span>
          </div>
          <button
            class="fullscreen-btn"
            id="fullscreen-btn"
            title="Toggle Fullscreen"
          >
            ‚õ∂
          </button>
        </div>
      </div>

      <div class="player-controls">
        <div class="song-info">
          <div class="album-art">üéµ</div>
          <div class="song-details">
            <div class="song-title" id="song-title">
              Chat with MoodBot to start your musical journey
            </div>
            <div class="mood-indicator" id="mood-indicator">Mood: None</div>
            <div class="track-info" id="track-info">Track 1 of 5</div>
          </div>
        </div>

        <div class="progress-container">
          <div class="progress-bar" id="progress-bar"></div>
        </div>

        <div class="controls">
          <button class="mode-btn active" id="shuffle-btn">üîÄ</button>
          <button class="control-btn" id="prev-btn">‚èÆ</button>
          <button class="play-btn control-btn" id="play-btn">‚ñ∂</button>
          <button class="control-btn" id="next-btn">‚è≠</button>
          <button class="mode-btn" id="sequential-btn">üîÅ</button>
        </div>
      </div>

      <footer>
        <p>MoodTune ¬© JinhuiLiang | AI-Enhanced Emotion-Based Music Player</p>
      </footer>
    </div>

    <script>
      // Global variables
      let currentMood = null;
      let isPlaying = false;
      let progressInterval;
      let currentAudio = null;
      let audioContext = null;
      let isFullscreen = false;
      let userInteracted = false;
      let chatHistory = [];
      let isTyping = false;

      // Playlist variables
      let currentPlaylist = [];
      let currentTrackIndex = 0;
      let isShuffleMode = true;
      let shuffleOrder = [];

      // Three.js variables
      let scene, camera, renderer;
      let animationFrame;
      let moodObjects = [];
      let time = 0;
      let particleSystems = [];

      // Mood to music playlists mapping - UPDATED TO 5 SONGS PER MOOD
      const moodPlaylists = {
        happy: {
          name: "Happy Vibes",
          color: [255, 223, 100],
          energy: 0.8,
          tracks: [
            { title: "Sunshine Day - Upbeat Pop", file: "audio/happy.mp3" },
            { title: "Good Vibes Only - Feel Good", file: "audio/happy2.mp3" },
            { title: "Dancing Colors - Joyful Beat", file: "audio/happy3.mp3" },
            {
              title: "Morning Joy - Bright Melodies",
              file: "audio/happy4.mp3",
            },
            {
              title: "Positive Energy - Happy Rhythms",
              file: "audio/happy5.mp3",
            },
          ],
        },
        sad: {
          name: "Melancholic Moods",
          color: [100, 150, 255],
          energy: 0.3,
          tracks: [
            { title: "Rainy Nights - Melancholic", file: "audio/sad.mp3" },
            { title: "Gentle Tears - Emotional", file: "audio/sad2.mp3" },
            {
              title: "Blue Reflections - Contemplative",
              file: "audio/sad3.mp3",
            },
            { title: "Lonely Echoes - Deep Thoughts", file: "audio/sad4.mp3" },
            { title: "Fading Memories - Nostalgic", file: "audio/sad5.mp3" },
          ],
        },
        calm: {
          name: "Peaceful Moments",
          color: [100, 220, 200],
          energy: 0.4,
          tracks: [
            { title: "Tranquil Waters - Ambient", file: "audio/calm.mp3" },
            { title: "Serene Forest - Nature Sounds", file: "audio/calm2.mp3" },
            { title: "Zen Garden - Meditation", file: "audio/calm3.mp3" },
            { title: "Peaceful Mind - Gentle Flow", file: "audio/calm4.mp3" },
            { title: "Still Moments - Quiet Harmony", file: "audio/calm5.mp3" },
          ],
        },
        energetic: {
          name: "High Energy",
          color: [255, 100, 100],
          energy: 0.9,
          tracks: [
            { title: "Electric Pulse - Dance", file: "audio/energetic.mp3" },
            { title: "Power Drive - Electronic", file: "audio/energetic2.mp3" },
            {
              title: "Adrenaline Rush - Intense",
              file: "audio/energetic3.mp3",
            },
            {
              title: "Thunder Storm - Powerful Beats",
              file: "audio/energetic4.mp3",
            },
            {
              title: "Fire Energy - Explosive Rhythms",
              file: "audio/energetic5.mp3",
            },
          ],
        },
        romantic: {
          name: "Love Songs",
          color: [255, 100, 200],
          energy: 0.6,
          tracks: [
            { title: "Hearts Entwined - Romance", file: "audio/romantic.mp3" },
            { title: "Sweet Serenade - Intimate", file: "audio/romantic2.mp3" },
            { title: "Moonlight Dance - Tender", file: "audio/romantic3.mp3" },
            { title: "Eternal Love - Passionate", file: "audio/romantic4.mp3" },
            {
              title: "Whispered Promises - Gentle",
              file: "audio/romantic5.mp3",
            },
          ],
        },
        focused: {
          name: "Focus Zone",
          color: [150, 200, 255],
          energy: 0.5,
          tracks: [
            {
              title: "Concentration Zone - Deep Focus",
              file: "audio/focused.mp3",
            },
            { title: "Mind Flow - Productivity", file: "audio/focused2.mp3" },
            {
              title: "Study Session - Ambient Work",
              file: "audio/focused3.mp3",
            },
            {
              title: "Mental Clarity - Cognitive Boost",
              file: "audio/focused4.mp3",
            },
            { title: "Deep Work - Intense Focus", file: "audio/focused5.mp3" },
          ],
        },
      };

      // AI Chat System
      const moodKeywords = {
        happy: {
          keywords: [
            "happy",
            "joy",
            "excited",
            "great",
            "awesome",
            "wonderful",
            "amazing",
            "fantastic",
            "good",
            "cheerful",
            "bright",
            "celebrate",
            "thrilled",
            "upbeat",
            "positive",
          ],
          responses: [
            "That's wonderful to hear! Your positive energy is contagious. Let me set up some upbeat music to match your mood.",
            "I love that enthusiasm! Happy vibes deserve happy music. Getting some sunshine sounds ready for you.",
            "What a great mood you're in! Time for some energetic tunes to keep those good feelings flowing.",
          ],
        },
        sad: {
          keywords: [
            "sad",
            "down",
            "depressed",
            "blue",
            "upset",
            "hurt",
            "cry",
            "tears",
            "lonely",
            "empty",
            "disappointed",
            "heartbroken",
            "grief",
            "loss",
            "melancholy",
          ],
          responses: [
            "I understand you're going through a tough time. Sometimes melancholic music can be comforting and help process these feelings.",
            "It's okay to feel sad sometimes. Let me find some gentle, contemplative music that might resonate with your current state.",
            "Sadness is a valid emotion. Would some soothing, reflective music help you work through what you're feeling?",
          ],
        },
        calm: {
          keywords: [
            "calm",
            "peaceful",
            "relaxed",
            "zen",
            "tranquil",
            "serene",
            "quiet",
            "still",
            "centered",
            "meditative",
            "chill",
            "mellow",
            "restful",
            "soothing",
          ],
          responses: [
            "A peaceful state of mind is beautiful. Let me create a tranquil soundscape to enhance your sense of calm.",
            "Zen vibes detected! Time for some ambient, flowing music to complement your inner peace.",
            "That sounds wonderfully serene. I'll set up some meditative tunes to maintain that peaceful energy.",
          ],
        },
        energetic: {
          keywords: [
            "energy",
            "pumped",
            "hyped",
            "active",
            "dynamic",
            "powerful",
            "intense",
            "charged",
            "electric",
            "motivated",
            "driven",
            "fired up",
            "amped",
            "vigorous",
          ],
          responses: [
            "I can feel that energy! Time to channel it with some high-octane music that matches your intensity.",
            "You're charged up and ready to go! Let me find some powerful beats to fuel that momentum.",
            "That's the spirit! High-energy music coming right up to match your dynamic mood.",
          ],
        },
        romantic: {
          keywords: [
            "love",
            "romance",
            "heart",
            "romantic",
            "intimate",
            "passion",
            "sweet",
            "tender",
            "affection",
            "relationship",
            "partner",
            "date",
            "valentine",
            "crush",
          ],
          responses: [
            "Love is in the air! Let me set a romantic atmosphere with some beautiful, heartfelt melodies.",
            "Aww, that's sweet! Time for some tender, romantic music to complement those lovely feelings.",
            "Romance calls for special music. I'll create the perfect soundtrack for your heart's desires.",
          ],
        },
        focused: {
          keywords: [
            "focus",
            "concentrate",
            "work",
            "study",
            "productive",
            "clear",
            "sharp",
            "determined",
            "mindful",
            "task",
            "project",
            "deadline",
            "learning",
            "analysis",
          ],
          responses: [
            "Time to get in the zone! I'll set up some focused, concentration-enhancing music for maximum productivity.",
            "Perfect mindset for deep work. Let me create an audio environment that supports your concentration.",
            "That focused energy is powerful. Here's some music designed to enhance cognitive performance and maintain attention.",
          ],
        },
      };

      const conversationStarters = [
        "What's been the highlight of your day so far?",
        "Tell me about something that's been on your mind lately.",
        "How would you describe your energy level right now?",
        "What kind of atmosphere would make you feel most comfortable?",
        "Are there any particular emotions you've been experiencing today?",
      ];

      const followUpQuestions = {
        happy: [
          "What's making you feel so positive today?",
          "How would you like to celebrate this mood?",
        ],
        sad: [
          "Would you like to talk about what's troubling you?",
          "Sometimes music helps - shall we find something soothing?",
        ],
        calm: [
          "What helps you maintain this peaceful state?",
          "Are you looking to stay relaxed or perhaps energize yourself?",
        ],
        energetic: [
          "What's fueling this amazing energy?",
          "Ready to channel this into something creative or active?",
        ],
        romantic: [
          "Is there someone special you're thinking about?",
          "What kind of romantic atmosphere appeals to you?",
        ],
        focused: [
          "What are you working on that requires this concentration?",
          "How can I best support your productive mindset?",
        ],
      };

      // Three.js Initialization
      function initThree() {
        const container = document.getElementById("visualization-container");
        const canvas = document.getElementById("three-canvas");

        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x0a0a15, 10, 100);

        camera = new THREE.PerspectiveCamera(
          75,
          container.clientWidth / container.clientHeight,
          0.1,
          1000
        );
        camera.position.z = 30;

        renderer = new THREE.WebGLRenderer({
          canvas: canvas,
          antialias: true,
          alpha: true,
        });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        animate3D();
      }

      function clearMoodObjects() {
        moodObjects.forEach((obj) => {
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material)) {
              obj.material.forEach((mat) => mat.dispose());
            } else {
              obj.material.dispose();
            }
          }
          scene.remove(obj);
        });
        moodObjects = [];

        // Clear particle systems
        particleSystems.forEach((system) => {
          scene.remove(system);
          if (system.geometry) system.geometry.dispose();
          if (system.material) system.material.dispose();
        });
        particleSystems = [];
      }

      // Enhanced Mood-specific 3D animations
      function createHappyAnimation3D() {
        clearMoodObjects();

        // Create a central sun-like object
        const sunGeometry = new THREE.SphereGeometry(3, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({
          color: 0xffd700,
          emissive: 0xffd700,
          emissiveIntensity: 0.8,
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);
        moodObjects.push(sun);

        // Create orbiting planets with different colors and sizes
        for (let i = 0; i < 6; i++) {
          const size = Math.random() * 0.8 + 0.5;
          const geometry = new THREE.SphereGeometry(size, 16, 16);
          const material = new THREE.MeshPhongMaterial({
            color: new THREE.Color(`hsl(${Math.random() * 60 + 30}, 90%, 70%)`),
            emissive: new THREE.Color(
              `hsl(${Math.random() * 60 + 30}, 90%, 30%)`
            ),
          });

          const planet = new THREE.Mesh(geometry, material);
          const orbitRadius = 10 + i * 2;
          const orbitSpeed = 0.005 + Math.random() * 0.005;

          planet.position.set(
            Math.cos(i) * orbitRadius,
            (Math.sin(i) * orbitRadius) / 2,
            (Math.sin(i) * orbitRadius) / 3
          );

          planet.userData = {
            orbitRadius: orbitRadius,
            orbitSpeed: orbitSpeed,
            angle: (i * Math.PI) / 3,
          };

          scene.add(planet);
          moodObjects.push(planet);
        }

        // Create a particle system for confetti
        const particleCount = 300;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i += 3) {
          positions[i] = (Math.random() - 0.5) * 40;
          positions[i + 1] = (Math.random() - 0.5) * 40;
          positions[i + 2] = (Math.random() - 0.5) * 40;

          colors[i] = Math.random();
          colors[i + 1] = Math.random();
          colors[i + 2] = Math.random();
        }

        particles.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        particles.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        const particleMaterial = new THREE.PointsMaterial({
          size: 0.3,
          vertexColors: true,
          transparent: true,
          opacity: 0.8,
        });

        const particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);
        particleSystems.push(particleSystem);

        // Add dynamic lighting
        const pointLight = new THREE.PointLight(0xffd700, 2, 50);
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);
        moodObjects.push(pointLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7);
        scene.add(directionalLight);
        moodObjects.push(directionalLight);
      }

      function createSadAnimation3D() {
        clearMoodObjects();

        // Create a dark, stormy scene
        const cloudGeometry = new THREE.SphereGeometry(8, 7, 7);
        const cloudMaterial = new THREE.MeshPhongMaterial({
          color: 0x2c3e50,
          emissive: 0x2c3e50,
          emissiveIntensity: 0.1,
          transparent: true,
          opacity: 0.7,
        });

        const clouds = [];
        for (let i = 0; i < 5; i++) {
          const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
          cloud.position.set(
            (Math.random() - 0.5) * 30,
            5 + Math.random() * 10,
            (Math.random() - 0.5) * 20
          );
          cloud.scale.set(
            1 + Math.random() * 0.5,
            0.5 + Math.random() * 0.3,
            1 + Math.random() * 0.5
          );
          cloud.userData = {
            driftSpeed: 0.01 + Math.random() * 0.01,
          };
          scene.add(cloud);
          clouds.push(cloud);
          moodObjects.push(cloud);
        }

        // Enhanced rain particles
        const rainCount = 1500;
        const rainGeometry = new THREE.BufferGeometry();
        const rainPositions = new Float32Array(rainCount * 3);
        const rainVelocities = new Float32Array(rainCount);

        for (let i = 0; i < rainCount * 3; i += 3) {
          rainPositions[i] = (Math.random() - 0.5) * 50;
          rainPositions[i + 1] = Math.random() * 40;
          rainPositions[i + 2] = (Math.random() - 0.5) * 50;
          rainVelocities[i / 3] = 0.2 + Math.random() * 0.3;
        }

        rainGeometry.setAttribute(
          "position",
          new THREE.BufferAttribute(rainPositions, 3)
        );
        rainGeometry.userData = { velocities: rainVelocities };

        const rainMaterial = new THREE.PointsMaterial({
          color: 0x6495ed,
          size: 0.2,
          transparent: true,
          opacity: 0.7,
        });

        const rain = new THREE.Points(rainGeometry, rainMaterial);
        scene.add(rain);
        moodObjects.push(rain);

        // Add occasional lightning
        const lightningGeometry = new THREE.BufferGeometry();
        const lightningMaterial = new THREE.LineBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0,
        });

        const lightning = new THREE.Line(lightningGeometry, lightningMaterial);
        scene.add(lightning);
        moodObjects.push(lightning);

        // Add dim, blue-tinted lighting
        const ambientLight = new THREE.AmbientLight(0x4169e1, 0.3);
        scene.add(ambientLight);
        moodObjects.push(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0x6495ed, 0.5);
        directionalLight.position.set(0, 10, 0);
        scene.add(directionalLight);
        moodObjects.push(directionalLight);
      }

      function createCalmAnimation3D() {
        clearMoodObjects();

        // Create an underwater scene with coral and bubbles
        const waterGeometry = new THREE.BoxGeometry(60, 40, 60);
        const waterMaterial = new THREE.MeshPhongMaterial({
          color: 0x1e90ff,
          transparent: true,
          opacity: 0.1,
          side: THREE.BackSide,
        });

        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        scene.add(water);
        moodObjects.push(water);

        // Create coral formations
        for (let i = 0; i < 15; i++) {
          const coralGeometry = new THREE.ConeGeometry(
            0.5 + Math.random() * 1.5,
            3 + Math.random() * 5,
            4 + Math.floor(Math.random() * 4)
          );
          const coralMaterial = new THREE.MeshPhongMaterial({
            color: new THREE.Color(
              `hsl(${Math.random() * 30 + 330}, 70%, 60%)`
            ),
            emissive: new THREE.Color(
              `hsl(${Math.random() * 30 + 330}, 70%, 20%)`
            ),
          });

          const coral = new THREE.Mesh(coralGeometry, coralMaterial);
          coral.position.set(
            (Math.random() - 0.5) * 40,
            -15 + Math.random() * 5,
            (Math.random() - 0.5) * 40
          );
          coral.rotation.x = Math.random() * Math.PI;
          coral.rotation.z = Math.random() * Math.PI;

          scene.add(coral);
          moodObjects.push(coral);
        }

        // Create bubble particle system
        const bubbleCount = 100;
        const bubbleGeometry = new THREE.BufferGeometry();
        const bubblePositions = new Float32Array(bubbleCount * 3);
        const bubbleSizes = new Float32Array(bubbleCount);

        for (let i = 0; i < bubbleCount * 3; i += 3) {
          bubblePositions[i] = (Math.random() - 0.5) * 40;
          bubblePositions[i + 1] = -20 + Math.random() * 10;
          bubblePositions[i + 2] = (Math.random() - 0.5) * 40;
          bubbleSizes[i / 3] = 0.2 + Math.random() * 0.5;
        }

        bubbleGeometry.setAttribute(
          "position",
          new THREE.BufferAttribute(bubblePositions, 3)
        );
        bubbleGeometry.userData = { sizes: bubbleSizes };

        const bubbleMaterial = new THREE.PointsMaterial({
          color: 0x87ceeb,
          size: 0.5,
          transparent: true,
          opacity: 0.7,
          blending: THREE.AdditiveBlending,
        });

        const bubbles = new THREE.Points(bubbleGeometry, bubbleMaterial);
        scene.add(bubbles);
        moodObjects.push(bubbles);

        // Add caustic lighting effect
        const directionalLight = new THREE.DirectionalLight(0x87ceeb, 0.8);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);
        moodObjects.push(directionalLight);

        const pointLight = new THREE.PointLight(0x40e0d0, 0.5, 30);
        pointLight.position.set(0, 10, 0);
        scene.add(pointLight);
        moodObjects.push(pointLight);
      }

      function createEnergeticAnimation3D() {
        clearMoodObjects();

        // Create a pulsating energy core
        const coreGeometry = new THREE.IcosahedronGeometry(4, 2);
        const coreMaterial = new THREE.MeshPhongMaterial({
          color: 0xff4500,
          emissive: 0xff4500,
          emissiveIntensity: 0.8,
          wireframe: true,
          transparent: true,
          opacity: 0.9,
        });

        const core = new THREE.Mesh(coreGeometry, coreMaterial);
        scene.add(core);
        moodObjects.push(core);

        // Create energy beams
        const beamCount = 12;
        for (let i = 0; i < beamCount; i++) {
          const beamGeometry = new THREE.CylinderGeometry(0.1, 0.5, 15, 8);
          const beamMaterial = new THREE.MeshPhongMaterial({
            color: 0xffa500,
            emissive: 0xffa500,
            emissiveIntensity: 0.7,
            transparent: true,
            opacity: 0.8,
          });

          const beam = new THREE.Mesh(beamGeometry, beamMaterial);
          const angle = (i / beamCount) * Math.PI * 2;
          beam.position.set(Math.cos(angle) * 8, Math.sin(angle) * 8, 0);
          beam.rotation.z = angle + Math.PI / 2;

          beam.userData = {
            angle: angle,
            pulsePhase: Math.random() * Math.PI * 2,
          };

          scene.add(beam);
          moodObjects.push(beam);
        }

        // Create orbiting particles
        const particleCount = 200;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i += 3) {
          const radius = 10 + Math.random() * 15;
          const angle = Math.random() * Math.PI * 2;

          positions[i] = Math.cos(angle) * radius;
          positions[i + 1] = (Math.random() - 0.5) * 10;
          positions[i + 2] = Math.sin(angle) * radius;

          velocities[i] = (Math.random() - 0.5) * 0.1;
          velocities[i + 1] = (Math.random() - 0.5) * 0.1;
          velocities[i + 2] = (Math.random() - 0.5) * 0.1;
        }

        particles.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        particles.userData = { velocities: velocities };

        const particleMaterial = new THREE.PointsMaterial({
          color: 0xff6b6b,
          size: 0.3,
          transparent: true,
          opacity: 0.8,
          blending: THREE.AdditiveBlending,
        });

        const particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);
        particleSystems.push(particleSystem);

        // Add dynamic lighting
        const pointLight = new THREE.PointLight(0xff4500, 2, 50);
        pointLight.position.set(0, 0, 0);
        scene.add(pointLight);
        moodObjects.push(pointLight);

        const directionalLight = new THREE.DirectionalLight(0xffa500, 0.5);
        directionalLight.position.set(10, 10, 10);
        scene.add(directionalLight);
        moodObjects.push(directionalLight);
      }

      function createRomanticAnimation3D() {
        clearMoodObjects();

        // Create a central heart shape
        const heartShape = new THREE.Shape();
        heartShape.moveTo(0, 0);
        heartShape.bezierCurveTo(2, 2, 4, 0, 0, -3);
        heartShape.bezierCurveTo(-4, 0, -2, 2, 0, 0);

        const heartGeometry = new THREE.ExtrudeGeometry(heartShape, {
          depth: 0.5,
          bevelEnabled: true,
          bevelThickness: 0.1,
          bevelSize: 0.1,
          bevelSegments: 5,
        });

        const heartMaterial = new THREE.MeshPhongMaterial({
          color: 0xff1493,
          emissive: 0xff1493,
          emissiveIntensity: 0.3,
        });

        const heart = new THREE.Mesh(heartGeometry, heartMaterial);
        heart.scale.set(1.5, 1.5, 1.5);
        scene.add(heart);
        moodObjects.push(heart);

        // Create floating rose petals
        const petalCount = 50;
        const petalGeometry = new THREE.PlaneGeometry(0.8, 0.5);
        const petalMaterial = new THREE.MeshPhongMaterial({
          color: 0xff69b4,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.7,
        });

        for (let i = 0; i < petalCount; i++) {
          const petal = new THREE.Mesh(petalGeometry, petalMaterial);
          petal.position.set(
            (Math.random() - 0.5) * 30,
            (Math.random() - 0.5) * 20,
            (Math.random() - 0.5) * 20
          );
          petal.rotation.x = Math.random() * Math.PI;
          petal.rotation.y = Math.random() * Math.PI;
          petal.rotation.z = Math.random() * Math.PI;

          petal.userData = {
            floatSpeed: 0.005 + Math.random() * 0.005,
            rotationSpeed: (Math.random() - 0.5) * 0.02,
            floatOffset: Math.random() * Math.PI * 2,
          };

          scene.add(petal);
          moodObjects.push(petal);
        }

        // Create glowing particles
        const particleCount = 100;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i += 3) {
          positions[i] = (Math.random() - 0.5) * 25;
          positions[i + 1] = (Math.random() - 0.5) * 15;
          positions[i + 2] = (Math.random() - 0.5) * 15;

          colors[i] = 0.9 + Math.random() * 0.1; // Red
          colors[i + 1] = 0.4 + Math.random() * 0.2; // Green
          colors[i + 2] = 0.5 + Math.random() * 0.3; // Blue
        }

        particles.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        particles.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        const particleMaterial = new THREE.PointsMaterial({
          size: 0.2,
          vertexColors: true,
          transparent: true,
          opacity: 0.8,
          blending: THREE.AdditiveBlending,
        });

        const particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);
        particleSystems.push(particleSystem);

        // Add romantic lighting
        const pointLight1 = new THREE.PointLight(0xff1493, 1.5, 30);
        pointLight1.position.set(10, 10, 10);
        scene.add(pointLight1);
        moodObjects.push(pointLight1);

        const pointLight2 = new THREE.PointLight(0xff69b4, 1, 25);
        pointLight2.position.set(-10, 5, -10);
        scene.add(pointLight2);
        moodObjects.push(pointLight2);

        const ambientLight = new THREE.AmbientLight(0x8b008b, 0.3);
        scene.add(ambientLight);
        moodObjects.push(ambientLight);
      }

      function createFocusedAnimation3D() {
        clearMoodObjects();

        // Create a neural network-like structure
        const nodeCount = 30;
        const nodes = [];
        const connections = [];

        // Create nodes
        for (let i = 0; i < nodeCount; i++) {
          const geometry = new THREE.SphereGeometry(0.5, 8, 8);
          const material = new THREE.MeshPhongMaterial({
            color: 0x00bfff,
            emissive: 0x00bfff,
            emissiveIntensity: 0.5,
          });

          const node = new THREE.Mesh(geometry, material);
          node.position.set(
            (Math.random() - 0.5) * 25,
            (Math.random() - 0.5) * 15,
            (Math.random() - 0.5) * 15
          );

          node.userData = {
            pulsePhase: Math.random() * Math.PI * 2,
            pulseSpeed: 0.02 + Math.random() * 0.02,
            originalPosition: node.position.clone(),
          };

          scene.add(node);
          nodes.push(node);
          moodObjects.push(node);
        }

        // Create connections between nodes
        for (let i = 0; i < nodeCount; i++) {
          for (let j = i + 1; j < nodeCount; j++) {
            if (Math.random() < 0.1) {
              // 10% chance to connect
              const distance = nodes[i].position.distanceTo(nodes[j].position);
              if (distance < 15) {
                const connectionGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(6);
                positions[0] = nodes[i].position.x;
                positions[1] = nodes[i].position.y;
                positions[2] = nodes[i].position.z;
                positions[3] = nodes[j].position.x;
                positions[4] = nodes[j].position.y;
                positions[5] = nodes[j].position.z;

                connectionGeometry.setAttribute(
                  "position",
                  new THREE.BufferAttribute(positions, 3)
                );

                const connectionMaterial = new THREE.LineBasicMaterial({
                  color: 0x1e90ff,
                  transparent: true,
                  opacity: 0.5,
                });

                const connection = new THREE.Line(
                  connectionGeometry,
                  connectionMaterial
                );
                scene.add(connection);
                connections.push(connection);
                moodObjects.push(connection);
              }
            }
          }
        }

        // Create data flow particles
        const particleCount = 50;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const targets = new Float32Array(particleCount * 3);
        const progress = new Float32Array(particleCount);

        for (let i = 0; i < particleCount; i++) {
          const startNode = nodes[Math.floor(Math.random() * nodes.length)];
          const endNode = nodes[Math.floor(Math.random() * nodes.length)];

          positions[i * 3] = startNode.position.x;
          positions[i * 3 + 1] = startNode.position.y;
          positions[i * 3 + 2] = startNode.position.z;

          targets[i * 3] = endNode.position.x;
          targets[i * 3 + 1] = endNode.position.y;
          targets[i * 3 + 2] = endNode.position.z;

          progress[i] = 0;
        }

        particles.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        particles.userData = { targets: targets, progress: progress };

        const particleMaterial = new THREE.PointsMaterial({
          color: 0x00ffff,
          size: 0.2,
          transparent: true,
          opacity: 0.8,
          blending: THREE.AdditiveBlending,
        });

        const particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);
        particleSystems.push(particleSystem);

        // Add focused lighting
        const directionalLight = new THREE.DirectionalLight(0x1e90ff, 1);
        directionalLight.position.set(0, 10, 10);
        scene.add(directionalLight);
        moodObjects.push(directionalLight);

        const ambientLight = new THREE.AmbientLight(0x0000ff, 0.2);
        scene.add(ambientLight);
        moodObjects.push(ambientLight);
      }

      // Update animations
      function updateMoodAnimation3D() {
        if (!currentMood) return;

        time++;

        // Update mood-specific animations
        moodObjects.forEach((obj, index) => {
          if (currentMood === "happy") {
            if (
              obj.geometry &&
              obj.geometry.type === "SphereGeometry" &&
              obj !== moodObjects[0]
            ) {
              // Update orbiting planets
              obj.userData.angle += obj.userData.orbitSpeed;
              obj.position.x =
                Math.cos(obj.userData.angle) * obj.userData.orbitRadius;
              obj.position.z =
                Math.sin(obj.userData.angle) * obj.userData.orbitRadius;
              obj.rotation.y += 0.01;
            }

            if (obj === moodObjects[0]) {
              // Pulsate the sun
              obj.scale.set(
                1 + Math.sin(time * 0.05) * 0.1,
                1 + Math.sin(time * 0.05) * 0.1,
                1 + Math.sin(time * 0.05) * 0.1
              );
            }
          }

          if (currentMood === "sad") {
            if (obj.type === "Points" && obj.geometry.attributes.position) {
              // Update rain particles
              const positions = obj.geometry.attributes.position.array;
              const velocities = obj.geometry.userData.velocities;

              for (let i = 0; i < positions.length; i += 3) {
                positions[i + 1] -= velocities[i / 3];
                if (positions[i + 1] < -20) {
                  positions[i + 1] = 20;
                  positions[i] = (Math.random() - 0.5) * 50;
                  positions[i + 2] = (Math.random() - 0.5) * 50;
                }
              }

              obj.geometry.attributes.position.needsUpdate = true;
            }

            if (obj.geometry && obj.geometry.type === "SphereGeometry") {
              // Drift clouds
              obj.position.x += obj.userData.driftSpeed;
              if (obj.position.x > 25) obj.position.x = -25;
            }

            // Occasional lightning
            if (
              obj.material &&
              obj.material.type === "LineBasicMaterial" &&
              Math.random() < 0.005
            ) {
              obj.material.opacity = 1;
              setTimeout(() => {
                obj.material.opacity = 0;
              }, 100);
            }
          }

          if (currentMood === "calm") {
            if (obj.type === "Points" && obj.geometry.attributes.position) {
              // Update bubble particles
              const positions = obj.geometry.attributes.position.array;
              const sizes = obj.geometry.userData.sizes;

              for (let i = 0; i < positions.length; i += 3) {
                positions[i + 1] += 0.05 + sizes[i / 3] * 0.05;
                if (positions[i + 1] > 20) {
                  positions[i + 1] = -20;
                  positions[i] = (Math.random() - 0.5) * 40;
                  positions[i + 2] = (Math.random() - 0.5) * 40;
                }
              }

              obj.geometry.attributes.position.needsUpdate = true;
            }
          }

          if (currentMood === "energetic") {
            if (obj.geometry && obj.geometry.type === "IcosahedronGeometry") {
              // Rotate and pulsate the core
              obj.rotation.x += 0.02;
              obj.rotation.y += 0.03;
              obj.scale.set(
                1 + Math.sin(time * 0.1) * 0.2,
                1 + Math.sin(time * 0.1) * 0.2,
                1 + Math.sin(time * 0.1) * 0.2
              );
            }

            if (obj.geometry && obj.geometry.type === "CylinderGeometry") {
              // Pulsate energy beams
              obj.userData.pulsePhase += 0.1;
              const scale = 1 + Math.sin(obj.userData.pulsePhase) * 0.3;
              obj.scale.y = scale;
            }

            if (obj.type === "Points" && obj.geometry.attributes.position) {
              // Update orbiting particles
              const positions = obj.geometry.attributes.position.array;
              const velocities = obj.geometry.userData.velocities;

              for (let i = 0; i < positions.length; i += 3) {
                // Move particles
                positions[i] += velocities[i];
                positions[i + 1] += velocities[i + 1];
                positions[i + 2] += velocities[i + 2];

                // Bounce off imaginary boundaries
                if (Math.abs(positions[i]) > 25) velocities[i] *= -1;
                if (Math.abs(positions[i + 1]) > 15) velocities[i + 1] *= -1;
                if (Math.abs(positions[i + 2]) > 25) velocities[i + 2] *= -1;
              }

              obj.geometry.attributes.position.needsUpdate = true;
            }
          }

          if (currentMood === "romantic") {
            if (obj.geometry && obj.geometry.type === "ExtrudeGeometry") {
              // Rotate and float the heart
              obj.rotation.y += 0.01;
              obj.position.y = Math.sin(time * 0.02) * 0.5;
            }

            if (obj.geometry && obj.geometry.type === "PlaneGeometry") {
              // Float and rotate rose petals
              obj.userData.floatOffset += obj.userData.floatSpeed;
              obj.position.y += Math.sin(obj.userData.floatOffset) * 0.02;
              obj.rotation.z += obj.userData.rotationSpeed;

              // Reset if out of bounds
              if (obj.position.y > 15) obj.position.y = -15;
            }
          }

          if (currentMood === "focused") {
            if (obj.geometry && obj.geometry.type === "SphereGeometry") {
              // Pulsate nodes
              obj.userData.pulsePhase += obj.userData.pulseSpeed;
              const scale = 1 + Math.sin(obj.userData.pulsePhase) * 0.2;
              obj.scale.set(scale, scale, scale);

              // Slight movement around original position
              obj.position.x =
                obj.userData.originalPosition.x +
                Math.sin(time * 0.01 + index) * 0.5;
              obj.position.y =
                obj.userData.originalPosition.y +
                Math.cos(time * 0.01 + index) * 0.3;
            }

            if (obj.type === "Points" && obj.geometry.attributes.position) {
              // Move data flow particles
              const positions = obj.geometry.attributes.position.array;
              const targets = obj.geometry.userData.targets;
              const progress = obj.geometry.userData.progress;

              for (let i = 0; i < positions.length; i += 3) {
                progress[i / 3] += 0.01;

                if (progress[i / 3] >= 1) {
                  progress[i / 3] = 0;
                  // Reset to new random target
                  const startNode = moodObjects[Math.floor(Math.random() * 30)]; // Assuming first 30 are nodes
                  const endNode = moodObjects[Math.floor(Math.random() * 30)];

                  if (startNode && endNode) {
                    positions[i] = startNode.position.x;
                    positions[i + 1] = startNode.position.y;
                    positions[i + 2] = startNode.position.z;

                    targets[i] = endNode.position.x;
                    targets[i + 1] = endNode.position.y;
                    targets[i + 2] = endNode.position.z;
                  }
                } else {
                  // Interpolate between start and target
                  positions[i] =
                    positions[i] + (targets[i] - positions[i]) * 0.05;
                  positions[i + 1] =
                    positions[i + 1] +
                    (targets[i + 1] - positions[i + 1]) * 0.05;
                  positions[i + 2] =
                    positions[i + 2] +
                    (targets[i + 2] - positions[i + 2]) * 0.05;
                }
              }

              obj.geometry.attributes.position.needsUpdate = true;
            }
          }
        });

        // Update particle systems
        particleSystems.forEach((system) => {
          if (system.geometry.attributes.position) {
            system.geometry.attributes.position.needsUpdate = true;
          }
        });
      }

      function animate3D() {
        animationFrame = requestAnimationFrame(animate3D);

        updateMoodAnimation3D();

        if (!currentMood) {
          // Default camera movement when no mood is selected
          camera.position.x = Math.sin(time * 0.005) * 10;
          camera.position.y = Math.cos(time * 0.005) * 5;
          camera.position.z = 30 + Math.sin(time * 0.003) * 5;
        } else {
          // Mood-specific camera movements
          switch (currentMood) {
            case "happy":
              camera.position.x = Math.sin(time * 0.01) * 15;
              camera.position.y = 5 + Math.cos(time * 0.005) * 3;
              camera.position.z = 25 + Math.sin(time * 0.007) * 5;
              break;
            case "sad":
              camera.position.x = Math.sin(time * 0.005) * 10;
              camera.position.y = 0 + Math.cos(time * 0.003) * 2;
              camera.position.z = 20 + Math.sin(time * 0.004) * 3;
              break;
            case "calm":
              camera.position.x = Math.sin(time * 0.003) * 8;
              camera.position.y = -5 + Math.cos(time * 0.002) * 2;
              camera.position.z = 25 + Math.sin(time * 0.002) * 3;
              break;
            case "energetic":
              camera.position.x = Math.sin(time * 0.02) * 8;
              camera.position.y = Math.cos(time * 0.015) * 5;
              camera.position.z = 20 + Math.sin(time * 0.01) * 5;
              break;
            case "romantic":
              camera.position.x = Math.sin(time * 0.005) * 12;
              camera.position.y = 3 + Math.cos(time * 0.003) * 2;
              camera.position.z = 18 + Math.sin(time * 0.004) * 3;
              break;
            case "focused":
              camera.position.x = Math.sin(time * 0.003) * 10;
              camera.position.y = 0 + Math.cos(time * 0.002) * 2;
              camera.position.z = 22 + Math.sin(time * 0.002) * 3;
              break;
          }
        }

        camera.lookAt(0, 0, 0);
        renderer.render(scene, camera);

        time++;
      }

      // Playlist Functions
      function generateShuffleOrder(playlistLength) {
        const order = Array.from({ length: playlistLength }, (_, i) => i);
        for (let i = order.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [order[i], order[j]] = [order[j], order[i]];
        }
        return order;
      }

      function getNextTrackIndex() {
        if (!currentPlaylist.length) return 0;

        if (isShuffleMode) {
          if (shuffleOrder.length === 0) {
            shuffleOrder = generateShuffleOrder(currentPlaylist.length);
          }

          const currentShuffleIndex = shuffleOrder.indexOf(currentTrackIndex);
          const nextShuffleIndex =
            (currentShuffleIndex + 1) % shuffleOrder.length;
          return shuffleOrder[nextShuffleIndex];
        } else {
          return (currentTrackIndex + 1) % currentPlaylist.length;
        }
      }

      function getPreviousTrackIndex() {
        if (!currentPlaylist.length) return 0;

        if (isShuffleMode) {
          if (shuffleOrder.length === 0) {
            shuffleOrder = generateShuffleOrder(currentPlaylist.length);
          }

          const currentShuffleIndex = shuffleOrder.indexOf(currentTrackIndex);
          const prevShuffleIndex =
            currentShuffleIndex === 0
              ? shuffleOrder.length - 1
              : currentShuffleIndex - 1;
          return shuffleOrder[prevShuffleIndex];
        } else {
          return currentTrackIndex === 0
            ? currentPlaylist.length - 1
            : currentTrackIndex - 1;
        }
      }

      function playTrack(trackIndex) {
        if (
          !currentPlaylist.length ||
          trackIndex < 0 ||
          trackIndex >= currentPlaylist.length
        ) {
          return;
        }

        currentTrackIndex = trackIndex;
        const track = currentPlaylist[currentTrackIndex];

        updateTrackInfo();
        loadAudioForTrack(track);

        if (userInteracted) {
          autoPlayMood();
        }
      }

      function playNext() {
        const nextIndex = getNextTrackIndex();
        playTrack(nextIndex);
      }

      function playPrevious() {
        const prevIndex = getPreviousTrackIndex();
        playTrack(prevIndex);
      }

      function updateTrackInfo() {
        if (!currentPlaylist.length) return;

        const track = currentPlaylist[currentTrackIndex];
        const moodData = moodPlaylists[currentMood];

        document.getElementById("song-title").textContent = track.title;
        document.getElementById("track-info").textContent = `Track ${
          currentTrackIndex + 1
        } of ${currentPlaylist.length} ‚Ä¢ ${moodData.name}`;
      }

      function togglePlaybackMode() {
        isShuffleMode = !isShuffleMode;

        const shuffleBtn = document.getElementById("shuffle-btn");
        const sequentialBtn = document.getElementById("sequential-btn");

        if (isShuffleMode) {
          shuffleBtn.classList.add("active");
          sequentialBtn.classList.remove("active");
          shuffleOrder = generateShuffleOrder(currentPlaylist.length);
        } else {
          shuffleBtn.classList.remove("active");
          sequentialBtn.classList.add("active");
          shuffleOrder = [];
        }
      }

      // AI Chat Functions
      function addMessage(
        content,
        isUser = false,
        hasSuggestion = false,
        suggestedMood = null
      ) {
        const messagesContainer = document.getElementById("chat-messages");
        const messageDiv = document.createElement("div");
        messageDiv.className = `message ${isUser ? "user" : "ai"}`;

        const headerDiv = document.createElement("div");
        headerDiv.className = "message-header";
        headerDiv.textContent = isUser ? "You" : "MoodBot";

        const contentDiv = document.createElement("div");
        contentDiv.className = "message-content";
        contentDiv.textContent = content;

        messageDiv.appendChild(headerDiv);
        messageDiv.appendChild(contentDiv);

        if (hasSuggestion && suggestedMood) {
          const suggestionDiv = document.createElement("div");
          suggestionDiv.className = "mood-suggestion";
          suggestionDiv.onclick = () => selectMoodFromChat(suggestedMood);

          const suggestionText = document.createElement("div");
          suggestionText.className = "mood-suggestion-text";
          suggestionText.textContent = `üéµ Switch to ${
            suggestedMood.charAt(0).toUpperCase() + suggestedMood.slice(1)
          } mood`;

          suggestionDiv.appendChild(suggestionText);
          messageDiv.appendChild(suggestionDiv);
        }

        messagesContainer.appendChild(messageDiv);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;

        chatHistory.push({
          content: content,
          isUser: isUser,
          timestamp: Date.now(),
          suggestedMood: suggestedMood,
        });
      }

      function showTypingIndicator() {
        const typingIndicator = document.getElementById("typing-indicator");
        typingIndicator.style.display = "flex";
        isTyping = true;

        const messagesContainer = document.getElementById("chat-messages");
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }

      function hideTypingIndicator() {
        const typingIndicator = document.getElementById("typing-indicator");
        typingIndicator.style.display = "none";
        isTyping = false;
      }

      function analyzeMoodFromText(text) {
        const lowerText = text.toLowerCase();
        let detectedMood = null;
        let maxScore = 0;
        let matchedKeywords = [];

        const musicTerms = [
          "music",
          "song",
          "track",
          "tune",
          "sound",
          "audio",
          "play",
          "listen",
          "hear",
        ];
        const hasMusicRequest = musicTerms.some((term) =>
          lowerText.includes(term)
        );

        Object.entries(moodKeywords).forEach(([mood, data]) => {
          const score = data.keywords.reduce((count, keyword) => {
            if (lowerText.includes(keyword)) {
              matchedKeywords.push(keyword);
              return count + 1;
            }
            return count;
          }, 0);

          if (score > maxScore) {
            maxScore = score;
            detectedMood = mood;
          }
        });

        const confidenceMultiplier = hasMusicRequest ? 1.5 : 1;
        const adjustedScore = maxScore * confidenceMultiplier;

        return {
          mood: detectedMood,
          confidence: adjustedScore > 0 ? Math.min(adjustedScore * 0.25, 1) : 0,
          keywords: matchedKeywords,
          hasMusicRequest: hasMusicRequest,
        };
      }

      function generateAIResponse(userMessage) {
        const analysis = analyzeMoodFromText(userMessage);
        let response = "";
        let suggestedMood = null;

        const confidenceThreshold = analysis.hasMusicRequest ? 0.2 : 0.3;

        if (analysis.confidence > confidenceThreshold && analysis.mood) {
          const moodData = moodKeywords[analysis.mood];
          response =
            moodData.responses[
              Math.floor(Math.random() * moodData.responses.length)
            ];
          suggestedMood = analysis.mood;
        } else if (analysis.confidence > 0.1 && analysis.mood) {
          response = `I'm picking up on some ${
            analysis.mood
          } vibes from what you're saying. ${
            followUpQuestions[analysis.mood][
              Math.floor(
                Math.random() * followUpQuestions[analysis.mood].length
              )
            ]
          }`;
        } else if (analysis.hasMusicRequest) {
          response =
            "I can tell you're looking for some music! To give you the perfect soundtrack, could you tell me more about your current mood or what kind of atmosphere you're going for?";
        } else {
          const responses = [
            "I'd love to understand your mood better. " +
              conversationStarters[
                Math.floor(Math.random() * conversationStarters.length)
              ],
            "Tell me more about how you're feeling. Are you looking for something upbeat, calming, or perhaps energizing?",
            "I'm here to help you find the perfect music for your state of mind. What's your emotional landscape like right now?",
            "Every mood deserves the right soundtrack. Help me understand what you're going through so I can curate something special for you.",
          ];
          response = responses[Math.floor(Math.random() * responses.length)];
        }

        return { response: response, suggestedMood: suggestedMood };
      }

      function sendChatMessage() {
        const chatInput = document.getElementById("chat-input");
        const message = chatInput.value.trim();

        if (!message || isTyping) return;

        addMessage(message, true);
        chatInput.value = "";
        autoResizeTextarea(chatInput);

        showTypingIndicator();

        setTimeout(() => {
          hideTypingIndicator();
          const aiResponse = generateAIResponse(message);
          addMessage(
            aiResponse.response,
            false,
            aiResponse.suggestedMood !== null,
            aiResponse.suggestedMood
          );
        }, 1000 + Math.random() * 1000);
      }

      function selectMoodFromChat(mood, instantPlay = false) {
        selectMood(mood);

        if (instantPlay) {
          setTimeout(() => {
            if (!isPlaying) {
              togglePlayPause();
            }
          }, 500);
        }

        setTimeout(
          () => {
            const confirmationMessages = instantPlay
              ? [
                  `üéµ Perfect! Now playing ${mood} playlist with ${
                    currentPlaylist.length
                  } tracks in ${
                    isShuffleMode ? "shuffle" : "sequential"
                  } mode. Enjoy!`,
                  `üé∂ Excellent! Your ${mood} playlist is now live with matching visuals. Let the vibes flow!`,
                  `‚ú® Amazing! ${
                    mood.charAt(0).toUpperCase() + mood.slice(1)
                  } playlist activated with instant music playback!`,
                ]
              : [
                  `Perfect! I've loaded the ${mood} playlist with ${currentPlaylist.length} tracks. Click play when you're ready!`,
                  `Great choice! ${
                    mood.charAt(0).toUpperCase() + mood.slice(1)
                  } playlist is ready with matching visuals. Hit play to start!`,
                  `Excellent! Your ${mood} playlist is set up in ${
                    isShuffleMode ? "shuffle" : "sequential"
                  } mode. Ready when you are!`,
                ];

            const confirmation =
              confirmationMessages[
                Math.floor(Math.random() * confirmationMessages.length)
              ];
            addMessage(confirmation, false);
          },
          instantPlay ? 1000 : 500
        );
      }

      function autoResizeTextarea(textarea) {
        textarea.style.height = "auto";
        textarea.style.height = Math.min(textarea.scrollHeight, 100) + "px";
      }

      function initChatEventListeners() {
        const chatInput = document.getElementById("chat-input");
        const sendBtn = document.getElementById("send-btn");

        chatInput.addEventListener("input", (e) => {
          autoResizeTextarea(e.target);
        });

        sendBtn.addEventListener("click", sendChatMessage);

        chatInput.addEventListener("keypress", (e) => {
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            sendChatMessage();
          }
        });

        chatInput.addEventListener("input", () => {
          sendBtn.disabled = isTyping;
        });
      }

      // Audio Functions
      function initializeAudio() {
        if (!audioContext) {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
        }
      }

      function loadAudioForTrack(track) {
        if (currentAudio) {
          currentAudio.pause();
          currentAudio.currentTime = 0;
          currentAudio.removeEventListener("loadstart", handleLoadStart);
          currentAudio.removeEventListener(
            "canplaythrough",
            handleCanPlayThrough
          );
          currentAudio.removeEventListener("error", handleAudioError);
          currentAudio.removeEventListener("timeupdate", updateProgressBar);
          currentAudio.removeEventListener("ended", handleTrackEnded);
          currentAudio = null;
        }

        if (progressInterval) {
          clearInterval(progressInterval);
          progressInterval = null;
        }

        if (track.file) {
          try {
            currentAudio = new Audio(track.file);
            currentAudio.loop = false;
            currentAudio.volume = 0.7;
            currentAudio.preload = "auto";

            currentAudio.addEventListener("loadstart", handleLoadStart);
            currentAudio.addEventListener(
              "canplaythrough",
              handleCanPlayThrough
            );
            currentAudio.addEventListener("error", handleAudioError);
            currentAudio.addEventListener("timeupdate", updateProgressBar);
            currentAudio.addEventListener("ended", handleTrackEnded);

            currentAudio.load();
          } catch (error) {
            console.error(`Failed to create audio for ${track.title}:`, error);
            fallbackToSimulation();
          }
        } else {
          fallbackToSimulation();
        }
      }

      function handleLoadStart() {
        document.getElementById("song-title").style.color = "#a1a8c9";
      }

      function handleCanPlayThrough() {
        document.getElementById("song-title").style.color = "#fff";
      }

      function handleAudioError(e) {
        console.error("Audio loading error:", e);
        fallbackToSimulation();
      }

      function handleTrackEnded() {
        console.log("Track ended, playing next...");
        playNext();
      }

      function fallbackToSimulation() {
        simulatePlayback();
      }

      function simulatePlayback() {
        isPlaying = true;
        document.getElementById("play-btn").textContent = "‚è∏";

        let progress = 0;
        const trackDuration = 180;
        const increment = 100 / (trackDuration * 10);

        progressInterval = setInterval(() => {
          if (!isPlaying) {
            clearInterval(progressInterval);
            progressInterval = null;
            return;
          }

          progress += increment;
          if (progress >= 100) {
            progress = 100;
            setTimeout(() => {
              if (isPlaying) {
                playNext();
              }
            }, 500);
          }

          document.getElementById("progress-bar").style.width = `${progress}%`;
        }, 100);
      }

      function updateProgressBar() {
        if (
          currentAudio &&
          currentAudio.duration &&
          !isNaN(currentAudio.duration)
        ) {
          const progress =
            (currentAudio.currentTime / currentAudio.duration) * 100;
          document.getElementById("progress-bar").style.width = `${progress}%`;
        }
      }

      function autoPlayMood() {
        if (!userInteracted) {
          return;
        }

        initializeAudio();

        if (!currentAudio) {
          simulatePlayback();
          return;
        }

        setTimeout(() => {
          if (currentAudio && currentAudio.readyState >= 3) {
            playAudio();
          } else if (currentAudio) {
            currentAudio.addEventListener("canplaythrough", playAudio, {
              once: true,
            });
            setTimeout(() => {
              if (!isPlaying) {
                fallbackToSimulation();
              }
            }, 3000);
          } else {
            fallbackToSimulation();
          }
        }, 100);
      }

      function playAudio() {
        if (!currentAudio) {
          fallbackToSimulation();
          return;
        }

        isPlaying = true;
        document.getElementById("play-btn").textContent = "‚è∏";

        if (audioContext && audioContext.state === "suspended") {
          audioContext.resume();
        }

        currentAudio
          .play()
          .then(() => {
            console.log(
              `Successfully playing: ${currentPlaylist[currentTrackIndex].title}`
            );
          })
          .catch((error) => {
            console.error("Audio play failed:", error);
            fallbackToSimulation();
          });
      }

      // Mood Selection
      function selectMood(mood) {
        userInteracted = true;

        if (currentMood) {
          clearMoodObjects();
        }

        currentMood = mood;
        const moodData = moodPlaylists[mood];

        currentPlaylist = [...moodData.tracks];
        currentTrackIndex = 0;

        if (isShuffleMode) {
          shuffleOrder = generateShuffleOrder(currentPlaylist.length);
          currentTrackIndex = shuffleOrder[0];
        }

        document.querySelectorAll(".mood-btn").forEach((btn) => {
          btn.classList.remove("active");
        });
        document.querySelector(`[data-mood="${mood}"]`).classList.add("active");

        document.getElementById("current-mood-display").textContent =
          mood.charAt(0).toUpperCase() + mood.slice(1);
        document.getElementById("mood-indicator").textContent = `Mood: ${
          mood.charAt(0).toUpperCase() + mood.slice(1)
        }`;

        updateTrackInfo();

        // Create 3D animation for selected mood
        switch (mood) {
          case "happy":
            createHappyAnimation3D();
            break;
          case "sad":
            createSadAnimation3D();
            break;
          case "calm":
            createCalmAnimation3D();
            break;
          case "energetic":
            createEnergeticAnimation3D();
            break;
          case "romantic":
            createRomanticAnimation3D();
            break;
          case "focused":
            createFocusedAnimation3D();
            break;
        }

        const firstTrack = currentPlaylist[currentTrackIndex];
        loadAudioForTrack(firstTrack);
        autoPlayMood();
      }

      function analyzeText() {
        const text = document.getElementById("mood-text").value.trim();
        if (!text) return;

        userInteracted = true;
        const analysis = analyzeMoodFromText(text);
        let detectedMood = analysis.mood || "calm";
        selectMood(detectedMood);
      }

      function togglePlayPause() {
        userInteracted = true;

        if (!currentMood) {
          selectMood("happy");
          return;
        }

        if (isPlaying) {
          pauseAudio();
        } else {
          resumeAudio();
        }
      }

      function pauseAudio() {
        isPlaying = false;
        document.getElementById("play-btn").textContent = "‚ñ∂";

        if (progressInterval) {
          clearInterval(progressInterval);
          progressInterval = null;
        }

        if (currentAudio) {
          currentAudio.pause();
        }
      }

      function resumeAudio() {
        if (currentAudio && currentAudio.readyState >= 3) {
          playAudio();
        } else if (currentAudio) {
          currentAudio.addEventListener("canplaythrough", playAudio, {
            once: true,
          });
        } else {
          simulatePlayback();
        }
      }

      // Fullscreen functionality
      function toggleFullscreen() {
        const visualizationContainer = document.getElementById(
          "visualization-container"
        );
        const fullscreenBtn = document.getElementById("fullscreen-btn");

        if (!isFullscreen) {
          if (visualizationContainer.requestFullscreen) {
            visualizationContainer.requestFullscreen();
          } else if (visualizationContainer.webkitRequestFullscreen) {
            visualizationContainer.webkitRequestFullscreen();
          } else if (visualizationContainer.mozRequestFullScreen) {
            visualizationContainer.mozRequestFullScreen();
          } else if (visualizationContainer.msRequestFullscreen) {
            visualizationContainer.msRequestFullscreen();
          } else {
            visualizationContainer.classList.add("fullscreen");
            isFullscreen = true;
            fullscreenBtn.innerHTML = "‚õ∂";
            fullscreenBtn.title = "Exit Fullscreen";
            handleResize();
          }
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          } else {
            visualizationContainer.classList.remove("fullscreen");
            isFullscreen = false;
            fullscreenBtn.innerHTML = "‚õ∂";
            fullscreenBtn.title = "Toggle Fullscreen";
            handleResize();
          }
        }
      }

      function handleFullscreenChange() {
        const visualizationContainer = document.getElementById(
          "visualization-container"
        );
        const fullscreenBtn = document.getElementById("fullscreen-btn");

        const isCurrentlyFullscreen = !!(
          document.fullscreenElement ||
          document.webkitFullscreenElement ||
          document.mozFullScreenElement ||
          document.msFullscreenElement
        );

        if (isCurrentlyFullscreen && !isFullscreen) {
          isFullscreen = true;
          visualizationContainer.classList.add("fullscreen");
          fullscreenBtn.innerHTML = "‚õ∑";
          fullscreenBtn.title = "Exit Fullscreen";
          handleResize();
        } else if (!isCurrentlyFullscreen && isFullscreen) {
          isFullscreen = false;
          visualizationContainer.classList.remove("fullscreen");
          fullscreenBtn.innerHTML = "‚õ∂";
          fullscreenBtn.title = "Toggle Fullscreen";
          handleResize();
        }
      }

      // Window resize handler
      function handleResize() {
        const container = document.getElementById("visualization-container");
        const width = container.clientWidth;
        const height = container.clientHeight;

        if (camera && renderer) {
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
          renderer.setSize(width, height);
        }
      }

      // Event Listeners
      function initEventListeners() {
        initChatEventListeners();

        document.querySelectorAll(".mood-btn").forEach((btn) => {
          btn.addEventListener("click", () => {
            const mood = btn.getAttribute("data-mood");
            selectMood(mood);
          });
        });

        document
          .getElementById("analyze-btn")
          .addEventListener("click", analyzeText);
        document
          .getElementById("play-btn")
          .addEventListener("click", togglePlayPause);

        // Shuffle and Sequential buttons
        document.getElementById("shuffle-btn").addEventListener("click", () => {
          if (!isShuffleMode) {
            togglePlaybackMode();
          }
        });

        document
          .getElementById("sequential-btn")
          .addEventListener("click", () => {
            if (isShuffleMode) {
              togglePlaybackMode();
            }
          });

        document
          .getElementById("prev-btn")
          .addEventListener("click", playPrevious);
        document.getElementById("next-btn").addEventListener("click", playNext);

        // Fullscreen button
        document
          .getElementById("fullscreen-btn")
          .addEventListener("click", toggleFullscreen);

        // Fullscreen change events
        document.addEventListener("fullscreenchange", handleFullscreenChange);
        document.addEventListener(
          "webkitfullscreenchange",
          handleFullscreenChange
        );
        document.addEventListener(
          "mozfullscreenchange",
          handleFullscreenChange
        );
        document.addEventListener("msfullscreenchange", handleFullscreenChange);

        // Progress bar click to seek
        document
          .querySelector(".progress-container")
          .addEventListener("click", (e) => {
            if (currentAudio && currentAudio.duration) {
              const rect = e.target.getBoundingClientRect();
              const clickX = e.clientX - rect.left;
              const percentage = clickX / rect.width;
              const newTime = percentage * currentAudio.duration;
              currentAudio.currentTime = newTime;
            }
          });

        // Volume control with mouse wheel on progress bar
        document
          .querySelector(".progress-container")
          .addEventListener("wheel", (e) => {
            e.preventDefault();
            if (currentAudio) {
              const volumeChange = e.deltaY > 0 ? -0.1 : 0.1;
              currentAudio.volume = Math.max(
                0,
                Math.min(1, currentAudio.volume + volumeChange)
              );

              const progressContainer = e.target.closest(".progress-container");
              progressContainer.style.opacity = currentAudio.volume;
              setTimeout(() => {
                progressContainer.style.opacity = "1";
              }, 200);
            }
          });

        // Keyboard shortcuts
        document.addEventListener("keydown", (e) => {
          if (e.target.tagName === "TEXTAREA") return;

          switch (e.code) {
            case "Space":
              e.preventDefault();
              togglePlayPause();
              break;
            case "KeyF":
              e.preventDefault();
              toggleFullscreen();
              break;
            case "ArrowUp":
              e.preventDefault();
              if (currentAudio) {
                currentAudio.volume = Math.min(1, currentAudio.volume + 0.1);
              }
              break;
            case "ArrowDown":
              e.preventDefault();
              if (currentAudio) {
                currentAudio.volume = Math.max(0, currentAudio.volume - 0.1);
              }
              break;
            case "ArrowLeft":
              e.preventDefault();
              if (currentAudio) {
                currentAudio.currentTime = Math.max(
                  0,
                  currentAudio.currentTime - 10
                );
              } else {
                playPrevious();
              }
              break;
            case "ArrowRight":
              e.preventDefault();
              if (currentAudio) {
                currentAudio.currentTime = Math.min(
                  currentAudio.duration || 0,
                  currentAudio.currentTime + 10
                );
              } else {
                playNext();
              }
              break;
            case "KeyN":
              e.preventDefault();
              playNext();
              break;
            case "KeyP":
              e.preventDefault();
              playPrevious();
              break;
            case "KeyS":
              e.preventDefault();
              togglePlaybackMode();
              break;
          }
        });

        document
          .getElementById("mood-text")
          .addEventListener("keypress", (e) => {
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              analyzeText();
            }
          });

        window.addEventListener("resize", handleResize);
      }

      // Initialize everything when page loads
      document.addEventListener("DOMContentLoaded", () => {
        initThree();
        initEventListeners();
        console.log(
          "MoodTune with upgraded 3D animations and all original functionality initialized!"
        );
        console.log(
          "Features: Multi-track playlists, Shuffle/Sequential modes, Advanced 3D mood animations"
        );
        console.log(
          "Keyboard shortcuts: Space (play/pause), N (next), P (previous), S (toggle shuffle), F (fullscreen)"
        );
      });
    </script>
  </body>
</html>
