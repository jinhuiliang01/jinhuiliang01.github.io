<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MoodTune - AI-Enhanced Emotion-Based Music Player</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sentiment/5.0.2/sentiment.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Poppins", sans-serif;
      }

      body {
        background: linear-gradient(
          135deg,
          #0a0a15 0%,
          #1a1a2e 50%,
          #16213e 100%
        );
        color: #fff;
        min-height: 100vh;
        overflow-x: hidden;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
      }

      header {
        text-align: center;
        padding: 30px 0;
        z-index: 10;
        position: relative;
      }

      h1 {
        font-size: 4rem;
        background: linear-gradient(45deg, #e94584, #0ff0fc, #ffd700, #ff6b6b);
        background-size: 400% 400%;
        background-clip: text;
        -webkit-background-clip: text;
        color: transparent;
        -webkit-text-fill-color: transparent;
        margin-bottom: 15px;
        text-shadow: 0 0 30px rgba(233, 69, 132, 0.5);
        animation: gradientShift 4s ease-in-out infinite;
        letter-spacing: 2px;
      }

      @keyframes gradientShift {
        0%,
        100% {
          background-position: 0% 50%;
        }
        50% {
          background-position: 100% 50%;
        }
      }

      .tagline {
        font-size: 1.4rem;
        color: #a1a8c9;
        margin-bottom: 40px;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      }

      .main-content {
        display: flex;
        flex: 1;
        gap: 40px;
        z-index: 10;
        margin-bottom: 30px;
      }

      .left-panel {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .ai-chat {
        background: rgba(255, 255, 255, 0.08);
        border-radius: 25px;
        padding: 30px;
        backdrop-filter: blur(15px);
        box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
        min-height: 400px;
        display: flex;
        flex-direction: column;
      }

      .mood-selector {
        background: rgba(255, 255, 255, 0.08);
        border-radius: 25px;
        padding: 30px;
        backdrop-filter: blur(15px);
        box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .visualization {
        flex: 2.5;
        border-radius: 25px;
        overflow: hidden;
        position: relative;
        box-shadow: 0 15px 60px rgba(0, 0, 0, 0.4);
        min-height: 600px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .section-title {
        font-size: 1.6rem;
        margin-bottom: 25px;
        color: #6e88ff;
        text-align: center;
        text-shadow: 0 2px 10px rgba(110, 136, 255, 0.3);
      }

      /* AI Chat Styles */
      .chat-messages {
        flex: 1;
        overflow-y: auto;
        margin-bottom: 20px;
        padding-right: 10px;
        max-height: 300px;
      }

      .message {
        margin-bottom: 15px;
        padding: 12px 18px;
        border-radius: 16px;
        max-width: 85%;
        animation: fadeInUp 0.3s ease;
      }

      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .message.ai {
        background: linear-gradient(
          135deg,
          rgba(110, 136, 255, 0.2),
          rgba(110, 136, 255, 0.1)
        );
        border-left: 3px solid #6e88ff;
        align-self: flex-start;
      }

      .message.user {
        background: linear-gradient(
          135deg,
          rgba(255, 107, 107, 0.2),
          rgba(255, 107, 107, 0.1)
        );
        border-left: 3px solid #ff6b6b;
        margin-left: auto;
        align-self: flex-end;
      }

      .message-header {
        font-size: 0.85rem;
        color: #a1a8c9;
        margin-bottom: 5px;
        font-weight: 500;
      }

      .message-content {
        line-height: 1.4;
        color: #fff;
      }

      .chat-input {
        display: flex;
        gap: 12px;
        align-items: flex-end;
      }

      .chat-input textarea {
        flex: 1;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 16px;
        padding: 12px 16px;
        color: #fff;
        font-size: 0.95rem;
        resize: none;
        min-height: 45px;
        max-height: 100px;
        transition: all 0.3s ease;
      }

      .chat-input textarea::placeholder {
        color: #a1a8c9;
      }

      .chat-input textarea:focus {
        outline: none;
        border: 2px solid #6e88ff;
        box-shadow: 0 0 15px rgba(110, 136, 255, 0.2);
        background: rgba(255, 255, 255, 0.12);
      }

      .send-btn {
        background: linear-gradient(135deg, #6e88ff, #8b5aff);
        border: none;
        color: white;
        width: 45px;
        height: 45px;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        font-size: 1.2rem;
        flex-shrink: 0;
      }

      .send-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 5px 15px rgba(110, 136, 255, 0.4);
      }

      .send-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .typing-indicator {
        display: none;
        align-items: center;
        gap: 8px;
        padding: 12px 18px;
        background: linear-gradient(
          135deg,
          rgba(110, 136, 255, 0.15),
          rgba(110, 136, 255, 0.08)
        );
        border-radius: 16px;
        border-left: 3px solid #6e88ff;
        max-width: 85%;
        margin-bottom: 15px;
      }

      .typing-dots {
        display: flex;
        gap: 4px;
      }

      .typing-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #6e88ff;
        animation: typingBounce 1.4s infinite ease-in-out;
      }

      .typing-dot:nth-child(2) {
        animation-delay: 0.2s;
      }

      .typing-dot:nth-child(3) {
        animation-delay: 0.4s;
      }

      @keyframes typingBounce {
        0%,
        80%,
        100% {
          transform: scale(0);
        }
        40% {
          transform: scale(1);
        }
      }

      .mood-suggestion {
        background: linear-gradient(
          135deg,
          rgba(255, 215, 0, 0.2),
          rgba(255, 215, 0, 0.1)
        );
        border: 2px solid rgba(255, 215, 0, 0.3);
        border-radius: 12px;
        padding: 12px;
        margin-top: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .mood-suggestion:hover {
        background: linear-gradient(
          135deg,
          rgba(255, 215, 0, 0.3),
          rgba(255, 215, 0, 0.15)
        );
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(255, 215, 0, 0.2);
      }

      .mood-suggestion-text {
        font-weight: 500;
        color: #ffd700;
      }

      .mood-buttons {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 18px;
        margin-bottom: 35px;
      }

      .mood-btn {
        padding: 18px;
        border: none;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.12);
        color: #fff;
        font-size: 1.1rem;
        cursor: pointer;
        transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        position: relative;
        overflow: hidden;
      }

      .mood-btn::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.2),
          transparent
        );
        transition: left 0.6s;
      }

      .mood-btn:hover::before {
        left: 100%;
      }

      .mood-btn:hover {
        transform: translateY(-5px) scale(1.05);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
      }

      .mood-btn.active {
        transform: translateY(-5px) scale(1.05);
        box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5);
        border: 2px solid rgba(255, 255, 255, 0.4);
      }

      .mood-btn.happy {
        background: linear-gradient(135deg, #ff9a9e, #fad0c4, #ffd89b);
        color: #333;
        box-shadow: 0 8px 25px rgba(255, 154, 158, 0.4);
      }
      .mood-btn.sad {
        background: linear-gradient(135deg, #4facfe, #00f2fe, #667eea);
        box-shadow: 0 8px 25px rgba(79, 172, 254, 0.4);
      }
      .mood-btn.calm {
        background: linear-gradient(135deg, #6a11cb, #2575fc, #43cea2);
        box-shadow: 0 8px 25px rgba(106, 17, 203, 0.4);
      }
      .mood-btn.energetic {
        background: linear-gradient(135deg, #f83600, #f9d423, #ff6b6b);
        color: #333;
        box-shadow: 0 8px 25px rgba(248, 54, 0, 0.4);
      }
      .mood-btn.romantic {
        background: linear-gradient(135deg, #ff057c, #8d0b93, #e94584);
        box-shadow: 0 8px 25px rgba(255, 5, 124, 0.4);
      }
      .mood-btn.focused {
        background: linear-gradient(135deg, #0ba360, #3cba92, #20bf6b);
        box-shadow: 0 8px 25px rgba(11, 163, 96, 0.4);
      }

      .text-input {
        margin-top: 30px;
      }

      textarea {
        width: 100%;
        height: 130px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 16px;
        padding: 18px;
        color: #fff;
        font-size: 1rem;
        margin-bottom: 18px;
        resize: none;
        transition: all 0.3s ease;
      }

      textarea::placeholder {
        color: #a1a8c9;
      }

      textarea:focus {
        outline: none;
        border: 2px solid #6e88ff;
        box-shadow: 0 0 20px rgba(110, 136, 255, 0.3);
        background: rgba(255, 255, 255, 0.12);
      }

      .analyze-btn {
        width: 100%;
        padding: 18px;
        border: none;
        border-radius: 16px;
        background: linear-gradient(135deg, #ff6b6b, #ff8e53, #ffa726);
        color: white;
        font-size: 1.1rem;
        cursor: pointer;
        transition: all 0.4s ease;
        box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);
        position: relative;
        overflow: hidden;
      }

      .analyze-btn::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.3),
          transparent
        );
        transition: left 0.6s;
      }

      .analyze-btn:hover::before {
        left: 100%;
      }

      .analyze-btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 12px 35px rgba(255, 107, 107, 0.5);
      }

      .player-controls {
        background: rgba(255, 255, 255, 0.08);
        border-radius: 25px;
        padding: 30px;
        margin-top: 30px;
        backdrop-filter: blur(15px);
        box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
        z-index: 10;
      }

      .song-info {
        display: flex;
        align-items: center;
        gap: 20px;
        margin-bottom: 25px;
      }

      .album-art {
        width: 90px;
        height: 90px;
        border-radius: 16px;
        background: linear-gradient(135deg, #8e2de2, #4a00e0);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2.2rem;
        box-shadow: 0 8px 25px rgba(142, 45, 226, 0.4);
        animation: pulse 2s ease-in-out infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      .song-details {
        flex: 1;
      }

      .song-title {
        font-size: 1.3rem;
        margin-bottom: 8px;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      }

      .mood-indicator {
        font-size: 1rem;
        color: #a1a8c9;
      }

      .progress-container {
        width: 100%;
        height: 8px;
        background: rgba(255, 255, 255, 0.12);
        border-radius: 4px;
        margin: 20px 0;
        cursor: pointer;
        position: relative;
        overflow: hidden;
      }

      .progress-bar {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #6e88ff, #ff6b6b, #ffd700);
        border-radius: 4px;
        transition: width 0.1s linear;
        box-shadow: 0 0 10px rgba(110, 136, 255, 0.5);
      }

      .controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 25px;
      }

      .control-btn {
        background: none;
        border: none;
        color: #fff;
        font-size: 1.6rem;
        cursor: pointer;
        padding: 12px;
        transition: all 0.3s ease;
        border-radius: 50%;
      }

      .control-btn:hover {
        color: #6e88ff;
        transform: scale(1.2);
        background: rgba(110, 136, 255, 0.2);
      }

      .play-btn {
        background: linear-gradient(135deg, #6e88ff, #ff6b6b);
        width: 70px;
        height: 70px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2rem;
        box-shadow: 0 8px 30px rgba(110, 136, 255, 0.5);
        transition: all 0.3s ease;
      }

      .play-btn:hover {
        transform: scale(1.1);
        box-shadow: 0 12px 40px rgba(110, 136, 255, 0.6);
      }

      .visual-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      .mood-display {
        position: absolute;
        bottom: 25px;
        right: 25px;
        background: rgba(0, 0, 0, 0.6);
        padding: 15px 25px;
        border-radius: 25px;
        font-size: 1.3rem;
        z-index: 11;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .fullscreen-btn {
        position: absolute;
        bottom: 25px;
        left: 25px;
        background: rgba(0, 0, 0, 0.6);
        border: none;
        color: #fff;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        font-size: 1.4rem;
        cursor: pointer;
        transition: all 0.3s ease;
        z-index: 11;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .fullscreen-btn:hover {
        background: rgba(110, 136, 255, 0.8);
        transform: scale(1.1);
        box-shadow: 0 8px 25px rgba(110, 136, 255, 0.5);
      }

      .fullscreen-btn:active {
        transform: scale(0.95);
      }

      /* Fullscreen styles */
      .visualization.fullscreen {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        z-index: 9999 !important;
        border-radius: 0 !important;
      }

      .visualization.fullscreen .mood-display {
        bottom: 40px;
        right: 40px;
        font-size: 1.5rem;
      }

      .visualization.fullscreen .fullscreen-btn {
        bottom: 40px;
        left: 40px;
        width: 70px;
        height: 70px;
        font-size: 1.6rem;
      }

      .mood-text {
        color: #ff6b6b;
        font-weight: bold;
        text-shadow: 0 2px 10px rgba(255, 107, 107, 0.5);
      }

      footer {
        text-align: center;
        padding: 30px 0;
        color: #a1a8c9;
        font-size: 1rem;
        z-index: 10;
      }

      @media (max-width: 1200px) {
        .main-content {
          flex-direction: column;
        }

        .left-panel {
          flex-direction: row;
        }

        .ai-chat {
          min-height: 350px;
        }

        h1 {
          font-size: 3rem;
        }

        .container {
          padding: 15px;
        }
      }

      @media (max-width: 800px) {
        .left-panel {
          flex-direction: column;
        }
      }

      /* Loading animation */
      .loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #6e88ff;
        font-size: 1.2rem;
        z-index: 12;
      }

      .spinner {
        width: 40px;
        height: 40px;
        margin: 0 auto 20px;
        border: 3px solid rgba(110, 136, 255, 0.3);
        border-top: 3px solid #6e88ff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Custom scrollbar for chat */
      .chat-messages::-webkit-scrollbar {
        width: 6px;
      }

      .chat-messages::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 3px;
      }

      .chat-messages::-webkit-scrollbar-thumb {
        background: rgba(110, 136, 255, 0.4);
        border-radius: 3px;
      }

      .chat-messages::-webkit-scrollbar-thumb:hover {
        background: rgba(110, 136, 255, 0.6);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>MoodTune</h1>
        <p class="tagline">Your AI-enhanced emotion-based music experience</p>
      </header>

      <div class="main-content">
        <div class="left-panel">
          <div class="ai-chat">
            <h2 class="section-title">Chat with MoodBot</h2>
            <div class="chat-messages" id="chat-messages">
              <div class="message ai">
                <div class="message-header">MoodBot</div>
                <div class="message-content">
                  Hello! I'm here to help you find the perfect music for your
                  mood. How are you feeling today? Tell me what's on your mind.
                </div>
              </div>
            </div>
            <div class="typing-indicator" id="typing-indicator">
              <div class="message-header">MoodBot is thinking...</div>
              <div class="typing-dots">
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
              </div>
            </div>
            <div class="chat-input">
              <textarea
                id="chat-input"
                placeholder="Tell me how you're feeling..."
                rows="1"
              ></textarea>
              <button class="send-btn" id="send-btn">➤</button>
            </div>
          </div>

          <div class="mood-selector">
            <h2 class="section-title">Quick Mood Select</h2>
            <div class="mood-buttons">
              <button class="mood-btn happy" data-mood="happy">😊 Happy</button>
              <button class="mood-btn sad" data-mood="sad">😢 Sad</button>
              <button class="mood-btn calm" data-mood="calm">😌 Calm</button>
              <button class="mood-btn energetic" data-mood="energetic">
                ⚡ Energetic
              </button>
              <button class="mood-btn romantic" data-mood="romantic">
                ❤️ Romantic
              </button>
              <button class="mood-btn focused" data-mood="focused">
                🎯 Focused
              </button>
            </div>

            <div class="text-input">
              <h2 class="section-title">Text Analysis</h2>
              <textarea
                id="mood-text"
                placeholder="Type how you're feeling today..."
              ></textarea>
              <button class="analyze-btn" id="analyze-btn">
                Analyze My Text
              </button>
            </div>
          </div>
        </div>

        <div class="visualization" id="visualization-container">
          <canvas id="visual-canvas" class="visual-canvas"></canvas>
          <div class="mood-display">
            Current Mood:
            <span class="mood-text" id="current-mood-display">None</span>
          </div>
          <button
            class="fullscreen-btn"
            id="fullscreen-btn"
            title="Toggle Fullscreen"
          >
            ⛶
          </button>
        </div>
      </div>

      <div class="player-controls">
        <div class="song-info">
          <div class="album-art">🎵</div>
          <div class="song-details">
            <div class="song-title" id="song-title">
              Chat with MoodBot to start your musical journey
            </div>
            <div class="mood-indicator" id="mood-indicator">Mood: None</div>
          </div>
        </div>

        <div class="progress-container">
          <div class="progress-bar" id="progress-bar"></div>
        </div>

        <div class="controls">
          <button class="control-btn">🔁</button>
          <button class="control-btn">⏮</button>
          <button class="play-btn control-btn" id="play-btn">▶</button>
          <button class="control-btn">⏭</button>
          <button class="control-btn">🔀</button>
        </div>
      </div>

      <footer>
        <p>MoodTune © JinhuiLiang | AI-Enhanced Emotion-Based Music Player</p>
      </footer>
    </div>

    <script>
      // Global variables
      let currentMood = null;
      let isPlaying = false;
      let progressInterval;
      let currentAudio = null;
      let audioContext = null;
      let isFullscreen = false;
      let userInteracted = false;
      let chatHistory = [];
      let isTyping = false;

      // Canvas variables
      let canvas, ctx;
      let animationFrame;
      let time = 0;
      let particles = [];
      let moodElements = [];

      // Romantic mood specific intervals
      let romanticParticleInterval;
      let romanticHeartInterval;

      // Mood to music mapping
      const moodMusic = {
        happy: {
          title: "Upbeat Pop - 'Sunshine Day'",
          color: [255, 223, 100],
          energy: 0.8,
          audioFile: "audio/happy.mp3",
        },
        sad: {
          title: "Melancholic Melodies - 'Rainy Nights'",
          color: [100, 150, 255],
          energy: 0.3,
          audioFile: "audio/sad.mp3",
        },
        calm: {
          title: "Ambient Relaxation - 'Tranquil Waters'",
          color: [100, 220, 200],
          energy: 0.4,
          audioFile: "audio/calm.mp3",
        },
        energetic: {
          title: "High Energy Dance - 'Electric Pulse'",
          color: [255, 100, 100],
          energy: 0.9,
          audioFile: "audio/energetic.mp3",
        },
        romantic: {
          title: "Romantic Instrumentals - 'Hearts Entwined'",
          color: [255, 100, 200],
          energy: 0.6,
          audioFile: "audio/romantic.mp3",
        },
        focused: {
          title: "Deep Focus - 'Concentration Zone'",
          color: [150, 200, 255],
          energy: 0.5,
          audioFile: "audio/focused.mp3",
        },
      };

      // AI Chat System
      const moodKeywords = {
        happy: {
          keywords: [
            "happy",
            "joy",
            "excited",
            "great",
            "awesome",
            "wonderful",
            "amazing",
            "fantastic",
            "good",
            "cheerful",
            "bright",
            "celebrate",
            "thrilled",
            "upbeat",
            "positive",
          ],
          responses: [
            "That's wonderful to hear! Your positive energy is contagious. Let me set up some upbeat music to match your mood.",
            "I love that enthusiasm! Happy vibes deserve happy music. Getting some sunshine sounds ready for you.",
            "What a great mood you're in! Time for some energetic tunes to keep those good feelings flowing.",
          ],
        },
        sad: {
          keywords: [
            "sad",
            "down",
            "depressed",
            "blue",
            "upset",
            "hurt",
            "cry",
            "tears",
            "lonely",
            "empty",
            "disappointed",
            "heartbroken",
            "grief",
            "loss",
            "melancholy",
          ],
          responses: [
            "I understand you're going through a tough time. Sometimes melancholic music can be comforting and help process these feelings.",
            "It's okay to feel sad sometimes. Let me find some gentle, contemplative music that might resonate with your current state.",
            "Sadness is a valid emotion. Would some soothing, reflective music help you work through what you're feeling?",
          ],
        },
        calm: {
          keywords: [
            "calm",
            "peaceful",
            "relaxed",
            "zen",
            "tranquil",
            "serene",
            "quiet",
            "still",
            "centered",
            "meditative",
            "chill",
            "mellow",
            "restful",
            "soothing",
          ],
          responses: [
            "A peaceful state of mind is beautiful. Let me create a tranquil soundscape to enhance your sense of calm.",
            "Zen vibes detected! Time for some ambient, flowing music to complement your inner peace.",
            "That sounds wonderfully serene. I'll set up some meditative tunes to maintain that peaceful energy.",
          ],
        },
        energetic: {
          keywords: [
            "energy",
            "pumped",
            "hyped",
            "active",
            "dynamic",
            "powerful",
            "intense",
            "charged",
            "electric",
            "motivated",
            "driven",
            "fired up",
            "amped",
            "vigorous",
          ],
          responses: [
            "I can feel that energy! Time to channel it with some high-octane music that matches your intensity.",
            "You're charged up and ready to go! Let me find some powerful beats to fuel that momentum.",
            "That's the spirit! High-energy music coming right up to match your dynamic mood.",
          ],
        },
        romantic: {
          keywords: [
            "love",
            "romance",
            "heart",
            "romantic",
            "intimate",
            "passion",
            "sweet",
            "tender",
            "affection",
            "relationship",
            "partner",
            "date",
            "valentine",
            "crush",
          ],
          responses: [
            "Love is in the air! Let me set a romantic atmosphere with some beautiful, heartfelt melodies.",
            "Aww, that's sweet! Time for some tender, romantic music to complement those lovely feelings.",
            "Romance calls for special music. I'll create the perfect soundtrack for your heart's desires.",
          ],
        },
        focused: {
          keywords: [
            "focus",
            "concentrate",
            "work",
            "study",
            "productive",
            "clear",
            "sharp",
            "determined",
            "mindful",
            "task",
            "project",
            "deadline",
            "learning",
            "analysis",
          ],
          responses: [
            "Time to get in the zone! I'll set up some focused, concentration-enhancing music for maximum productivity.",
            "Perfect mindset for deep work. Let me create an audio environment that supports your concentration.",
            "That focused energy is powerful. Here's some music designed to enhance cognitive performance and maintain attention.",
          ],
        },
      };

      const conversationStarters = [
        "What's been the highlight of your day so far?",
        "Tell me about something that's been on your mind lately.",
        "How would you describe your energy level right now?",
        "What kind of atmosphere would make you feel most comfortable?",
        "Are there any particular emotions you've been experiencing today?",
      ];

      const followUpQuestions = {
        happy: [
          "What's making you feel so positive today?",
          "How would you like to celebrate this mood?",
        ],
        sad: [
          "Would you like to talk about what's troubling you?",
          "Sometimes music helps - shall we find something soothing?",
        ],
        calm: [
          "What helps you maintain this peaceful state?",
          "Are you looking to stay relaxed or perhaps energize yourself?",
        ],
        energetic: [
          "What's fueling this amazing energy?",
          "Ready to channel this into something creative or active?",
        ],
        romantic: [
          "Is there someone special you're thinking about?",
          "What kind of romantic atmosphere appeals to you?",
        ],
        focused: [
          "What are you working on that requires this concentration?",
          "How can I best support your productive mindset?",
        ],
      };

      // AI Chat Functions
      function addMessage(
        content,
        isUser = false,
        hasSuggestion = false,
        suggestedMood = null
      ) {
        const messagesContainer = document.getElementById("chat-messages");
        const messageDiv = document.createElement("div");
        messageDiv.className = `message ${isUser ? "user" : "ai"}`;

        const headerDiv = document.createElement("div");
        headerDiv.className = "message-header";
        headerDiv.textContent = isUser ? "You" : "MoodBot";

        const contentDiv = document.createElement("div");
        contentDiv.className = "message-content";
        contentDiv.textContent = content;

        messageDiv.appendChild(headerDiv);
        messageDiv.appendChild(contentDiv);

        if (hasSuggestion && suggestedMood) {
          const suggestionDiv = document.createElement("div");
          suggestionDiv.className = "mood-suggestion";
          suggestionDiv.onclick = () => selectMoodFromChat(suggestedMood);

          const suggestionText = document.createElement("div");
          suggestionText.className = "mood-suggestion-text";
          suggestionText.textContent = `🎵 Switch to ${
            suggestedMood.charAt(0).toUpperCase() + suggestedMood.slice(1)
          } mood`;

          suggestionDiv.appendChild(suggestionText);
          messageDiv.appendChild(suggestionDiv);
        }

        messagesContainer.appendChild(messageDiv);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;

        // Store in chat history
        chatHistory.push({
          content: content,
          isUser: isUser,
          timestamp: Date.now(),
          suggestedMood: suggestedMood,
        });
      }

      function showTypingIndicator() {
        const typingIndicator = document.getElementById("typing-indicator");
        typingIndicator.style.display = "flex";
        isTyping = true;

        const messagesContainer = document.getElementById("chat-messages");
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }

      function hideTypingIndicator() {
        const typingIndicator = document.getElementById("typing-indicator");
        typingIndicator.style.display = "none";
        isTyping = false;
      }

      function analyzeMoodFromText(text) {
        const lowerText = text.toLowerCase();
        let detectedMood = null;
        let maxScore = 0;
        let matchedKeywords = [];

        // Check for explicit music requests first
        const musicTerms = [
          "music",
          "song",
          "track",
          "tune",
          "sound",
          "audio",
          "play",
          "listen",
          "hear",
        ];
        const hasMusicRequest = musicTerms.some((term) =>
          lowerText.includes(term)
        );

        Object.entries(moodKeywords).forEach(([mood, data]) => {
          const score = data.keywords.reduce((count, keyword) => {
            if (lowerText.includes(keyword)) {
              matchedKeywords.push(keyword);
              return count + 1;
            }
            return count;
          }, 0);

          if (score > maxScore) {
            maxScore = score;
            detectedMood = mood;
          }
        });

        // Lower the confidence threshold if user explicitly mentions music
        const confidenceMultiplier = hasMusicRequest ? 1.5 : 1;
        const adjustedScore = maxScore * confidenceMultiplier;

        return {
          mood: detectedMood,
          confidence: adjustedScore > 0 ? Math.min(adjustedScore * 0.25, 1) : 0,
          keywords: matchedKeywords,
          hasMusicRequest: hasMusicRequest,
        };
      }

      function generateAIResponse(userMessage) {
        const analysis = analyzeMoodFromText(userMessage);
        let response = "";
        let suggestedMood = null;

        // Lower threshold for music requests
        const confidenceThreshold = analysis.hasMusicRequest ? 0.2 : 0.3;

        if (analysis.confidence > confidenceThreshold && analysis.mood) {
          // High confidence mood detection
          const moodData = moodKeywords[analysis.mood];
          response =
            moodData.responses[
              Math.floor(Math.random() * moodData.responses.length)
            ];
          suggestedMood = analysis.mood;
        } else if (analysis.confidence > 0.1 && analysis.mood) {
          // Low confidence - ask follow-up questions
          response = `I'm picking up on some ${
            analysis.mood
          } vibes from what you're saying. ${
            followUpQuestions[analysis.mood][
              Math.floor(
                Math.random() * followUpQuestions[analysis.mood].length
              )
            ]
          }`;
        } else if (analysis.hasMusicRequest) {
          // User wants music but no clear mood detected
          response =
            "I can tell you're looking for some music! To give you the perfect soundtrack, could you tell me more about your current mood or what kind of atmosphere you're going for?";
        } else {
          // No clear mood detected - use conversation starters
          const responses = [
            "I'd love to understand your mood better. " +
              conversationStarters[
                Math.floor(Math.random() * conversationStarters.length)
              ],
            "Tell me more about how you're feeling. Are you looking for something upbeat, calming, or perhaps energizing?",
            "I'm here to help you find the perfect music for your state of mind. What's your emotional landscape like right now?",
            "Every mood deserves the right soundtrack. Help me understand what you're going through so I can curate something special for you.",
          ];
          response = responses[Math.floor(Math.random() * responses.length)];
        }

        return {
          response: response,
          suggestedMood: suggestedMood,
        };
      }

      function sendChatMessage() {
        const chatInput = document.getElementById("chat-input");
        const message = chatInput.value.trim();

        if (!message || isTyping) return;

        // Add user message
        addMessage(message, true);
        chatInput.value = "";
        autoResizeTextarea(chatInput);

        // Show typing indicator
        showTypingIndicator();

        // Generate AI response after a delay
        setTimeout(() => {
          hideTypingIndicator();

          const aiResponse = generateAIResponse(message);
          addMessage(
            aiResponse.response,
            false,
            aiResponse.suggestedMood !== null,
            aiResponse.suggestedMood
          );
        }, 1000 + Math.random() * 1000); // Random delay between 1-2 seconds
      }

      function selectMoodFromChat(mood, instantPlay = false) {
        selectMood(mood);

        // If instant play is requested, force play the music immediately
        if (instantPlay) {
          setTimeout(() => {
            if (!isPlaying) {
              togglePlayPause();
            }
          }, 500); // Small delay to ensure mood is fully loaded
        }

        // Add confirmation message
        setTimeout(
          () => {
            const confirmationMessages = instantPlay
              ? [
                  `🎵 Perfect! Now playing ${mood} music and showing matching visuals. Enjoy the experience!`,
                  `🎶 Excellent! Your ${mood} mood is now live with music and animations. Let the vibes flow!`,
                  `✨ Amazing! ${
                    mood.charAt(0).toUpperCase() + mood.slice(1)
                  } mode activated with instant music playback!`,
                ]
              : [
                  `Perfect! I've set the mood to ${mood}. Click play when you're ready to hear the music!`,
                  `Great choice! ${
                    mood.charAt(0).toUpperCase() + mood.slice(1)
                  } mood is ready - just hit play to start the music.`,
                  `Excellent! Your ${mood} mood is set up with matching visuals. Ready to play when you are!`,
                ];

            const confirmation =
              confirmationMessages[
                Math.floor(Math.random() * confirmationMessages.length)
              ];
            addMessage(confirmation, false);
          },
          instantPlay ? 1000 : 500
        );
      }

      function autoResizeTextarea(textarea) {
        textarea.style.height = "auto";
        textarea.style.height = Math.min(textarea.scrollHeight, 100) + "px";
      }

      // Initialize chat functionality
      function initChatEventListeners() {
        const chatInput = document.getElementById("chat-input");
        const sendBtn = document.getElementById("send-btn");

        // Auto-resize textarea
        chatInput.addEventListener("input", (e) => {
          autoResizeTextarea(e.target);
        });

        // Send message on button click
        sendBtn.addEventListener("click", sendChatMessage);

        // Send message on Enter key (but allow Shift+Enter for new lines)
        chatInput.addEventListener("keypress", (e) => {
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            sendChatMessage();
          }
        });

        // Disable send button when typing
        chatInput.addEventListener("input", () => {
          sendBtn.disabled = isTyping;
        });
      }

      // Helper function to convert HSL to RGBA
      function hslToRgba(hslColor) {
        const hslMatch = hslColor.match(
          /hsl\((\d+(?:\.\d+)?),\s*(\d+(?:\.\d+)?)%?,\s*(\d+(?:\.\d+)?)%?\)/
        );
        if (!hslMatch) {
          return { r: 255, g: 100, b: 200 };
        }

        const h = parseFloat(hslMatch[1]) / 360;
        const s = parseFloat(hslMatch[2]) / 100;
        const l = parseFloat(hslMatch[3]) / 100;

        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        };

        let r, g, b;
        if (s === 0) {
          r = g = b = l;
        } else {
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hue2rgb(p, q, h + 1 / 3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1 / 3);
        }

        return {
          r: Math.round(r * 255),
          g: Math.round(g * 255),
          b: Math.round(b * 255),
        };
      }

      // Helper function to convert HSL to HSLA
      function hslToHsla(hslColor, alpha) {
        return hslColor.replace("hsl(", "hsla(").replace(")", `, ${alpha})`);
      }

      // Helper function to adjust color alpha
      function adjustColorAlpha(colorStr, alpha) {
        if (colorStr.startsWith("hsl(")) {
          return hslToHsla(colorStr, alpha);
        } else if (colorStr.startsWith("rgb(")) {
          return colorStr.replace("rgb(", "rgba(").replace(")", `, ${alpha})`);
        } else if (colorStr.startsWith("rgba(")) {
          return colorStr.replace(
            /rgba\(([^,]+,[^,]+,[^,]+),([^)]+)\)/,
            `rgba($1,${alpha})`
          );
        }
        return colorStr;
      }

      // Particle class
      class Particle {
        constructor(x, y, vx, vy, color, size, life, type = "normal") {
          this.x = x;
          this.y = y;
          this.vx = vx;
          this.vy = vy;
          this.color = color;
          this.size = size;
          this.life = life;
          this.maxLife = life;
          this.type = type;
          this.alpha = 1;
          this.rotation = 0;
          this.rotationSpeed = (Math.random() - 0.5) * 0.1;
        }

        update() {
          this.x += this.vx;
          this.y += this.vy;
          this.life--;
          this.alpha = this.life / this.maxLife;
          this.rotation += this.rotationSpeed;

          if (this.type === "leaf" || this.type === "heart") {
            this.vx += Math.sin(time * 0.01 + this.x * 0.01) * 0.1;
          }
        }

        draw() {
          if (this.life <= 0) return;

          ctx.save();
          ctx.globalAlpha = this.alpha;
          ctx.translate(this.x, this.y);
          ctx.rotate(this.rotation);
          ctx.fillStyle = this.color;

          switch (this.type) {
            case "bubble":
              this.drawBubble();
              break;
            case "star":
              this.drawStar();
              break;
            case "heart":
              this.drawHeart();
              break;
            case "leaf":
              this.drawLeaf();
              break;
            default:
              ctx.beginPath();
              ctx.arc(0, 0, this.size, 0, Math.PI * 2);
              ctx.fill();
          }

          ctx.restore();
        }

        drawBubble() {
          const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
          gradient.addColorStop(0, adjustColorAlpha(this.color, 1));
          gradient.addColorStop(0.7, adjustColorAlpha(this.color, 0.5));
          gradient.addColorStop(1, adjustColorAlpha(this.color, 0.125));

          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(0, 0, this.size, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
          ctx.beginPath();
          ctx.arc(
            -this.size * 0.3,
            -this.size * 0.3,
            this.size * 0.3,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }

        drawStar() {
          ctx.fillStyle = this.color;
          const spikes = 5;
          const outerRadius = this.size;
          const innerRadius = this.size * 0.4;

          ctx.beginPath();
          for (let i = 0; i < spikes * 2; i++) {
            const angle = (i / (spikes * 2)) * Math.PI * 2;
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;

            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.fill();
        }

        drawHeart() {
          ctx.fillStyle = this.color;
          const size = this.size;

          ctx.beginPath();
          ctx.moveTo(0, size * 0.3);
          ctx.bezierCurveTo(0, 0, -size * 0.5, 0, -size * 0.5, size * 0.3);
          ctx.bezierCurveTo(-size * 0.5, size * 0.6, 0, size, 0, size);
          ctx.bezierCurveTo(
            0,
            size,
            size * 0.5,
            size * 0.6,
            size * 0.5,
            size * 0.3
          );
          ctx.bezierCurveTo(size * 0.5, 0, 0, 0, 0, size * 0.3);
          ctx.closePath();
          ctx.fill();

          ctx.shadowBlur = 10;
          ctx.shadowColor = this.color;
          ctx.fill();
        }

        drawLeaf() {
          const gradient = ctx.createLinearGradient(
            0,
            -this.size,
            0,
            this.size
          );
          gradient.addColorStop(0, adjustColorAlpha(this.color, 1));
          gradient.addColorStop(0.5, adjustColorAlpha(this.color, 0.67));
          gradient.addColorStop(1, adjustColorAlpha(this.color, 0.4));

          ctx.fillStyle = gradient;
          const size = this.size;

          ctx.beginPath();
          ctx.moveTo(0, -size);
          ctx.quadraticCurveTo(size * 0.6, -size * 0.2, 0, size);
          ctx.quadraticCurveTo(-size * 0.6, -size * 0.2, 0, -size);
          ctx.closePath();
          ctx.fill();
        }
      }

      // Clear romantic intervals function
      function clearRomanticIntervals() {
        if (romanticParticleInterval) {
          clearInterval(romanticParticleInterval);
          romanticParticleInterval = null;
        }
        if (romanticHeartInterval) {
          clearInterval(romanticHeartInterval);
          romanticHeartInterval = null;
        }
      }

      // Artistic mood animations
      function createHappyAnimation() {
        particles = [];
        moodElements = [];

        for (let i = 0; i < 8; i++) {
          moodElements.push({
            type: "rainbow_stream",
            x: Math.random() * canvas.width,
            y: -50,
            wave: i * 0.5,
            speed: 2 + Math.random() * 3,
            width: 20 + Math.random() * 30,
            colors: [
              `hsl(${60 + i * 30}, 80%, 70%)`,
              `hsl(${90 + i * 30}, 80%, 70%)`,
              `hsl(${120 + i * 30}, 80%, 70%)`,
            ],
          });
        }

        setInterval(() => {
          if (currentMood !== "happy") return;
          for (let i = 0; i < 5; i++) {
            particles.push(
              new Particle(
                Math.random() * canvas.width,
                Math.random() * canvas.height,
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2,
                `hsl(${Math.random() * 60 + 30}, 90%, 70%)`,
                3 + Math.random() * 8,
                60 + Math.random() * 60,
                "star"
              )
            );
          }
        }, 100);
      }

      function createSadAnimation() {
        particles = [];
        moodElements = [];

        moodElements.push({
          type: "rain_system",
          drops: [],
        });

        for (let i = 0; i < 15; i++) {
          moodElements.push({
            type: "mist_cloud",
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: 50 + Math.random() * 100,
            drift: Math.random() * 0.5,
            opacity: 0.1 + Math.random() * 0.3,
          });
        }

        setInterval(() => {
          if (currentMood !== "sad") return;
          particles.push(
            new Particle(
              Math.random() * canvas.width,
              -10,
              Math.sin(time * 0.01) * 0.5,
              2 + Math.random() * 3,
              `rgba(100, 150, 255, ${0.6 + Math.random() * 0.4})`,
              2 + Math.random() * 4,
              200 + Math.random() * 100
            )
          );
        }, 150);
      }

      function createCalmAnimation() {
        particles = [];
        moodElements = [];

        moodElements.push({
          type: "zen_garden",
          ripples: [],
        });

        for (let i = 0; i < 12; i++) {
          moodElements.push({
            type: "meditation_orb",
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            baseY: Math.random() * canvas.height,
            size: 15 + Math.random() * 25,
            phase: Math.random() * Math.PI * 2,
            color: `hsl(${180 + Math.random() * 60}, 60%, 65%)`,
          });
        }

        setInterval(() => {
          if (currentMood !== "calm") return;
          particles.push(
            new Particle(
              canvas.width / 2 + (Math.random() - 0.5) * 200,
              canvas.height / 2 + (Math.random() - 0.5) * 200,
              (Math.random() - 0.5) * 0.5,
              (Math.random() - 0.5) * 0.5,
              `hsla(${180 + Math.random() * 60}, 70%, 70%, 0.6)`,
              8 + Math.random() * 12,
              120 + Math.random() * 80,
              "bubble"
            )
          );
        }, 300);
      }

      function createEnergeticAnimation() {
        particles = [];
        moodElements = [];

        for (let i = 0; i < 6; i++) {
          moodElements.push({
            type: "energy_bolt",
            points: [],
            life: 30 + Math.random() * 20,
            color: `hsl(${Math.random() * 60 + 300}, 90%, 70%)`,
            width: 3 + Math.random() * 5,
          });
        }

        moodElements.push({
          type: "energy_core",
          x: canvas.width / 2,
          y: canvas.height / 2,
          size: 50,
          pulsePhase: 0,
        });

        setInterval(() => {
          if (currentMood !== "energetic") return;
          for (let i = 0; i < 8; i++) {
            const angle = ((Math.PI * 2) / 8) * i + time * 0.02;
            particles.push(
              new Particle(
                canvas.width / 2 + Math.cos(angle) * 100,
                canvas.height / 2 + Math.sin(angle) * 100,
                Math.cos(angle) * 5,
                Math.sin(angle) * 5,
                `hsl(${Math.random() * 60 + 15}, 100%, 60%)`,
                4 + Math.random() * 6,
                40 + Math.random() * 30,
                "star"
              )
            );
          }
        }, 80);
      }

      function createRomanticAnimation() {
        clearRomanticIntervals();
        particles = [];
        moodElements = [];

        for (let i = 0; i < 20; i++) {
          moodElements.push({
            type: "romantic_glow",
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: 30 + Math.random() * 60,
            pulse: Math.random() * Math.PI * 2,
            color: `hsl(${320 + Math.random() * 40}, 70%, 65%)`,
          });
        }

        romanticParticleInterval = setInterval(() => {
          if (currentMood !== "romantic") {
            clearRomanticIntervals();
            return;
          }

          for (let i = 0; i < 2; i++) {
            particles.push(
              new Particle(
                Math.random() * canvas.width,
                -20,
                (Math.random() - 0.5) * 2,
                1 + Math.random() * 2,
                `hsl(${340 + Math.random() * 40}, 80%, 70%)`,
                6 + Math.random() * 8,
                300 + Math.random() * 200,
                "leaf"
              )
            );
          }
        }, 150);

        romanticHeartInterval = setInterval(() => {
          if (currentMood !== "romantic") {
            clearRomanticIntervals();
            return;
          }

          particles.push(
            new Particle(
              Math.random() * canvas.width,
              canvas.height + 20,
              (Math.random() - 0.5) * 1,
              -1 - Math.random() * 2,
              `hsl(${340 + Math.random() * 20}, 90%, 75%)`,
              8 + Math.random() * 12,
              250 + Math.random() * 150,
              "heart"
            )
          );
        }, 300);
      }

      function createFocusedAnimation() {
        particles = [];
        moodElements = [];

        moodElements.push({
          type: "neural_network",
          nodes: [],
          connections: [],
        });

        const network = moodElements[0];
        for (let i = 0; i < 25; i++) {
          network.nodes.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: 4 + Math.random() * 8,
            pulse: Math.random() * Math.PI * 2,
            connections: [],
          });
        }

        network.nodes.forEach((node, i) => {
          for (let j = i + 1; j < network.nodes.length; j++) {
            const other = network.nodes[j];
            const dist = Math.hypot(node.x - other.x, node.y - other.y);
            if (dist < 150) {
              network.connections.push({
                from: node,
                to: other,
                strength: 1 - dist / 150,
                pulse: Math.random() * Math.PI * 2,
              });
            }
          }
        });

        setInterval(() => {
          if (currentMood !== "focused") return;
          const connection =
            network.connections[
              Math.floor(Math.random() * network.connections.length)
            ];
          if (connection) {
            particles.push(
              new Particle(
                connection.from.x,
                connection.from.y,
                (connection.to.x - connection.from.x) / 50,
                (connection.to.y - connection.from.y) / 50,
                `hsl(${200 + Math.random() * 40}, 80%, 70%)`,
                3 + Math.random() * 4,
                50,
                "normal"
              )
            );
          }
        }, 100);
      }

      // Canvas initialization
      function initCanvas() {
        canvas = document.getElementById("visual-canvas");
        ctx = canvas.getContext("2d");
        resizeCanvas();
        animate();
      }

      function resizeCanvas() {
        const container = document.getElementById("visualization-container");
        const rect = container.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
      }

      // Main animation loop
      function animate() {
        animationFrame = requestAnimationFrame(animate);
        time++;

        ctx.fillStyle = "rgba(10, 10, 21, 0.1)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (currentMood) {
          updateMoodAnimation();
        } else {
          drawDefaultVisualization();
        }

        updateParticles();
      }

      function updateMoodAnimation() {
        switch (currentMood) {
          case "happy":
            updateHappyAnimation();
            break;
          case "sad":
            updateSadAnimation();
            break;
          case "calm":
            updateCalmAnimation();
            break;
          case "energetic":
            updateEnergeticAnimation();
            break;
          case "romantic":
            updateRomanticAnimation();
            break;
          case "focused":
            updateFocusedAnimation();
            break;
        }
      }

      function updateHappyAnimation() {
        moodElements.forEach((element) => {
          if (element.type === "rainbow_stream") {
            element.y += element.speed;
            if (element.y > canvas.height + 50) {
              element.y = -50;
              element.x = Math.random() * canvas.width;
            }

            ctx.save();
            const gradient = ctx.createLinearGradient(
              0,
              element.y - 50,
              0,
              element.y + 50
            );
            element.colors.forEach((color, i) => {
              gradient.addColorStop(i / (element.colors.length - 1), color);
            });

            ctx.strokeStyle = gradient;
            ctx.lineWidth = element.width;
            ctx.lineCap = "round";

            ctx.beginPath();
            for (let i = 0; i < 100; i++) {
              const x = element.x + Math.sin(element.wave + i * 0.1) * 50;
              const y = element.y + i * 2;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.restore();
          }
        });
      }

      function updateSadAnimation() {
        moodElements.forEach((element) => {
          if (element.type === "mist_cloud") {
            element.x += element.drift;
            if (element.x > canvas.width + element.size) {
              element.x = -element.size;
            }

            ctx.save();
            ctx.globalAlpha = element.opacity;
            const gradient = ctx.createRadialGradient(
              element.x,
              element.y,
              element.size * 0.5,
              element.x,
              element.y,
              element.size
            );
            gradient.addColorStop(0, "rgba(100, 120, 180, 0.3)");
            gradient.addColorStop(1, "rgba(100, 120, 180, 0)");

            ctx.fillStyle = gradient;
            ctx.fillRect(
              element.x - element.size,
              element.y - element.size,
              element.size * 2,
              element.size * 2
            );
            ctx.restore();
          }
        });
      }

      function updateCalmAnimation() {
        moodElements.forEach((element) => {
          if (element.type === "meditation_orb") {
            element.y =
              element.baseY + Math.sin(time * 0.01 + element.phase) * 20;

            ctx.save();
            const gradient = ctx.createRadialGradient(
              element.x,
              element.y,
              0,
              element.x,
              element.y,
              element.size * 2
            );
            gradient.addColorStop(0, adjustColorAlpha(element.color, 0.8));
            gradient.addColorStop(0.5, adjustColorAlpha(element.color, 0.4));
            gradient.addColorStop(1, adjustColorAlpha(element.color, 0));

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(element.x, element.y, element.size * 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = adjustColorAlpha(element.color, 0.8);
            ctx.beginPath();
            ctx.arc(element.x, element.y, element.size * 0.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          } else if (element.type === "zen_garden") {
            if (Math.random() < 0.02) {
              element.ripples.push({
                x: Math.random() * canvas.width,
                y: canvas.height * 0.7 + Math.random() * canvas.height * 0.3,
                radius: 0,
                maxRadius: 80 + Math.random() * 100,
                life: 180,
              });
            }

            element.ripples = element.ripples.filter((ripple) => {
              ripple.radius += ripple.maxRadius / ripple.life;
              ripple.life--;

              if (ripple.life > 0) {
                ctx.save();
                ctx.globalAlpha = ripple.life / 180;
                ctx.strokeStyle = "rgba(100, 220, 200, 0.6)";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
                return true;
              }
              return false;
            });
          }
        });
      }

      function updateEnergeticAnimation() {
        moodElements.forEach((element) => {
          if (element.type === "energy_bolt") {
            element.life--;
            if (element.life <= 0 || element.points.length === 0) {
              element.points = [];
              element.life = 30 + Math.random() * 20;

              const startX = Math.random() * canvas.width;
              const startY = Math.random() * canvas.height * 0.3;
              const endX = Math.random() * canvas.width;
              const endY =
                canvas.height * 0.7 + Math.random() * canvas.height * 0.3;

              const segments = 8 + Math.random() * 8;
              for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const x =
                  startX + (endX - startX) * t + (Math.random() - 0.5) * 50;
                const y =
                  startY + (endY - startY) * t + (Math.random() - 0.5) * 30;
                element.points.push({ x, y });
              }
            }

            if (element.points.length > 1) {
              ctx.save();
              ctx.globalAlpha = Math.random() > 0.3 ? 0.8 : 0.3;
              ctx.strokeStyle = element.color;
              ctx.lineWidth = element.width;
              ctx.lineCap = "round";
              ctx.lineJoin = "round";

              ctx.beginPath();
              element.points.forEach((point, i) => {
                if (i === 0) ctx.moveTo(point.x, point.y);
                else ctx.lineTo(point.x, point.y);
              });
              ctx.stroke();

              ctx.shadowBlur = 20;
              ctx.shadowColor = element.color;
              ctx.stroke();
              ctx.restore();
            }
          } else if (element.type === "energy_core") {
            element.pulsePhase += 0.1;
            const pulseSize = element.size + Math.sin(element.pulsePhase) * 20;

            ctx.save();
            const gradient = ctx.createRadialGradient(
              element.x,
              element.y,
              0,
              element.x,
              element.y,
              pulseSize
            );
            gradient.addColorStop(0, "rgba(255, 100, 100, 0.8)");
            gradient.addColorStop(0.5, "rgba(255, 200, 0, 0.4)");
            gradient.addColorStop(1, "rgba(255, 100, 100, 0)");

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(element.x, element.y, pulseSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        });
      }

      function updateRomanticAnimation() {
        moodElements.forEach((element) => {
          if (element.type === "romantic_glow") {
            element.pulse += 0.03;
            const glowSize = element.size + Math.sin(element.pulse) * 15;

            ctx.save();
            ctx.globalAlpha = 0.4 + Math.sin(element.pulse) * 0.3;

            const rgbaColor = hslToRgba(element.color);

            const gradient = ctx.createRadialGradient(
              element.x,
              element.y,
              0,
              element.x,
              element.y,
              glowSize
            );

            gradient.addColorStop(
              0,
              `rgba(${rgbaColor.r}, ${rgbaColor.g}, ${rgbaColor.b}, 0.8)`
            );
            gradient.addColorStop(
              0.5,
              `rgba(${rgbaColor.r}, ${rgbaColor.g}, ${rgbaColor.b}, 0.4)`
            );
            gradient.addColorStop(
              1,
              `rgba(${rgbaColor.r}, ${rgbaColor.g}, ${rgbaColor.b}, 0)`
            );

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(element.x, element.y, glowSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        });
      }

      function updateFocusedAnimation() {
        moodElements.forEach((element) => {
          if (element.type === "neural_network") {
            element.nodes.forEach((node) => {
              node.pulse += 0.05;
            });

            ctx.save();
            element.connections.forEach((conn) => {
              conn.pulse += 0.1;
              const alpha = 0.3 + Math.sin(conn.pulse) * 0.2;

              ctx.globalAlpha = alpha * conn.strength;
              ctx.strokeStyle = `hsl(${
                200 + Math.sin(conn.pulse) * 20
              }, 70%, 60%)`;
              ctx.lineWidth = 1 + conn.strength * 2;

              ctx.beginPath();
              ctx.moveTo(conn.from.x, conn.from.y);
              ctx.lineTo(conn.to.x, conn.to.y);
              ctx.stroke();
            });

            element.nodes.forEach((node) => {
              const nodeSize = node.size + Math.sin(node.pulse) * 3;

              ctx.globalAlpha = 0.8;
              ctx.fillStyle = `hsl(${
                220 + Math.sin(node.pulse) * 10
              }, 80%, 70%)`;
              ctx.beginPath();
              ctx.arc(node.x, node.y, nodeSize, 0, Math.PI * 2);
              ctx.fill();

              ctx.globalAlpha = 0.3;
              ctx.fillStyle = `hsl(${
                220 + Math.sin(node.pulse) * 10
              }, 80%, 70%)`;
              ctx.beginPath();
              ctx.arc(node.x, node.y, nodeSize * 2, 0, Math.PI * 2);
              ctx.fill();
            });
            ctx.restore();
          }
        });
      }

      function updateParticles() {
        particles = particles.filter((particle) => {
          particle.update();
          particle.draw();
          return particle.life > 0;
        });
      }

      function drawDefaultVisualization() {
        ctx.save();
        ctx.globalAlpha = 0.5;

        for (let i = 0; i < 3; i++) {
          const x = canvas.width / 2 + Math.sin(time * 0.01 + i) * 100;
          const y = canvas.height / 2 + Math.cos(time * 0.015 + i) * 60;
          const size = 30 + Math.sin(time * 0.02 + i) * 15;

          const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
          gradient.addColorStop(0, "rgba(110, 136, 255, 0.6)");
          gradient.addColorStop(1, "rgba(110, 136, 255, 0)");

          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      // Audio functions
      function initializeAudio() {
        if (!audioContext) {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
        }
      }

      function loadAudioForMood(mood) {
        const moodData = moodMusic[mood];

        // Stop and clean up previous audio
        if (currentAudio) {
          currentAudio.pause();
          currentAudio.currentTime = 0;
          currentAudio.removeEventListener("loadstart", handleLoadStart);
          currentAudio.removeEventListener(
            "canplaythrough",
            handleCanPlayThrough
          );
          currentAudio.removeEventListener("error", handleAudioError);
          currentAudio.removeEventListener("timeupdate", updateProgressBar);
          currentAudio.removeEventListener("ended", handleAudioEnded);
          currentAudio = null;
        }

        // Clear any existing progress interval
        if (progressInterval) {
          clearInterval(progressInterval);
          progressInterval = null;
        }

        // Create new audio instance
        if (moodData.audioFile) {
          try {
            currentAudio = new Audio(moodData.audioFile);
            currentAudio.loop = true;
            currentAudio.volume = 0.7;
            currentAudio.preload = "auto";

            // Add event listeners
            currentAudio.addEventListener("loadstart", handleLoadStart);
            currentAudio.addEventListener(
              "canplaythrough",
              handleCanPlayThrough
            );
            currentAudio.addEventListener("error", handleAudioError);
            currentAudio.addEventListener("timeupdate", updateProgressBar);
            currentAudio.addEventListener("ended", handleAudioEnded);

            console.log(`Loading audio: ${moodData.audioFile}`);

            // Load the audio
            currentAudio.load();
          } catch (error) {
            console.error(`Failed to create audio for ${mood}:`, error);
            showAudioError(mood);
            fallbackToSimulation();
          }
        } else {
          console.log(`No audio file specified for ${mood} mood`);
          fallbackToSimulation();
        }
      }

      // Audio event handlers
      function handleLoadStart() {
        console.log("Audio loading started...");
        document.getElementById("song-title").style.color = "#a1a8c9";
      }

      function handleCanPlayThrough() {
        console.log("Audio ready to play");
        document.getElementById("song-title").style.color = "#fff";
      }

      function handleAudioError(e) {
        console.error("Audio loading error:", e);
        console.error("Error details:", {
          error: currentAudio ? currentAudio.error : "Unknown",
          networkState: currentAudio ? currentAudio.networkState : "Unknown",
          readyState: currentAudio ? currentAudio.readyState : "Unknown",
        });

        showAudioError(currentMood);
        fallbackToSimulation();
      }

      function handleAudioEnded() {
        if (isPlaying) {
          currentAudio.currentTime = 0;
          currentAudio.play().catch(handlePlayError);
        }
      }

      function handlePlayError(error) {
        console.error("Play error:", error);
        showAudioError(currentMood);
        fallbackToSimulation();
      }

      function showAudioError(mood) {
        const songTitle = document.getElementById("song-title");
        songTitle.textContent = `${moodMusic[mood].title} (Audio unavailable - check file path)`;
        songTitle.style.color = "#ff6b6b";

        setTimeout(() => {
          songTitle.style.color = "#fff";
        }, 4000);
      }

      function fallbackToSimulation() {
        console.log("Falling back to simulation mode");
        simulatePlayback();
      }

      function simulatePlayback() {
        isPlaying = true;
        document.getElementById("play-btn").textContent = "⏸";

        let progress = 0;
        progressInterval = setInterval(() => {
          if (!isPlaying) {
            clearInterval(progressInterval);
            progressInterval = null;
            return;
          }

          progress += 0.3;
          if (progress >= 100) {
            progress = 0;
          }

          document.getElementById("progress-bar").style.width = `${progress}%`;
        }, 100);
      }

      function updateProgressBar() {
        if (
          currentAudio &&
          currentAudio.duration &&
          !isNaN(currentAudio.duration)
        ) {
          const progress =
            (currentAudio.currentTime / currentAudio.duration) * 100;
          document.getElementById("progress-bar").style.width = `${progress}%`;
        }
      }

      function autoPlayMood() {
        if (!userInteracted) {
          console.log("Cannot autoplay - no user interaction yet");
          return;
        }

        initializeAudio();

        if (!currentAudio) {
          console.log("No audio file loaded, using simulation mode");
          simulatePlayback();
          return;
        }

        setTimeout(() => {
          if (currentAudio && currentAudio.readyState >= 3) {
            playAudio();
          } else if (currentAudio) {
            currentAudio.addEventListener("canplaythrough", playAudio, {
              once: true,
            });

            setTimeout(() => {
              if (!isPlaying) {
                console.log("Audio load timeout, falling back to simulation");
                fallbackToSimulation();
              }
            }, 3000);
          } else {
            fallbackToSimulation();
          }
        }, 100);
      }

      function playAudio() {
        if (!currentAudio) {
          fallbackToSimulation();
          return;
        }

        isPlaying = true;
        document.getElementById("play-btn").textContent = "⏸";

        if (audioContext && audioContext.state === "suspended") {
          audioContext.resume();
        }

        currentAudio
          .play()
          .then(() => {
            console.log(`Successfully playing audio for ${currentMood}`);
          })
          .catch((error) => {
            console.error("Audio play failed:", error);
            handlePlayError(error);
          });
      }

      // Mood selection function
      function selectMood(mood) {
        userInteracted = true;

        // Clear previous mood
        if (currentMood) {
          clearRomanticIntervals();
          particles = [];
          moodElements = [];
        }

        currentMood = mood;
        const moodData = moodMusic[mood];

        // Update UI
        document.querySelectorAll(".mood-btn").forEach((btn) => {
          btn.classList.remove("active");
        });
        document.querySelector(`[data-mood="${mood}"]`).classList.add("active");

        document.getElementById("current-mood-display").textContent =
          mood.charAt(0).toUpperCase() + mood.slice(1);
        document.getElementById("song-title").textContent = moodData.title;
        document.getElementById("mood-indicator").textContent = `Mood: ${
          mood.charAt(0).toUpperCase() + mood.slice(1)
        }`;

        // Start animation
        switch (mood) {
          case "happy":
            createHappyAnimation();
            break;
          case "sad":
            createSadAnimation();
            break;
          case "calm":
            createCalmAnimation();
            break;
          case "energetic":
            createEnergeticAnimation();
            break;
          case "romantic":
            createRomanticAnimation();
            break;
          case "focused":
            createFocusedAnimation();
            break;
        }

        loadAudioForMood(mood);
        autoPlayMood();
      }

      // Text analysis function
      function analyzeText() {
        const text = document.getElementById("mood-text").value.trim();
        if (!text) return;

        userInteracted = true;

        const analysis = analyzeMoodFromText(text);
        let detectedMood = analysis.mood || "calm";

        selectMood(detectedMood);
      }

      // Play/pause toggle
      function togglePlayPause() {
        userInteracted = true;

        if (!currentMood) {
          selectMood("happy");
          return;
        }

        if (isPlaying) {
          pauseAudio();
        } else {
          resumeAudio();
        }
      }

      function pauseAudio() {
        isPlaying = false;
        document.getElementById("play-btn").textContent = "▶";

        if (progressInterval) {
          clearInterval(progressInterval);
          progressInterval = null;
        }

        if (currentAudio) {
          currentAudio.pause();
        }
      }

      function resumeAudio() {
        if (currentAudio && currentAudio.readyState >= 3) {
          playAudio();
        } else if (currentAudio) {
          currentAudio.addEventListener("canplaythrough", playAudio, {
            once: true,
          });
        } else {
          simulatePlayback();
        }
      }

      // Fullscreen functionality
      function toggleFullscreen() {
        const visualizationContainer = document.getElementById(
          "visualization-container"
        );
        const fullscreenBtn = document.getElementById("fullscreen-btn");

        if (!isFullscreen) {
          if (visualizationContainer.requestFullscreen) {
            visualizationContainer.requestFullscreen();
          } else if (visualizationContainer.webkitRequestFullscreen) {
            visualizationContainer.webkitRequestFullscreen();
          } else if (visualizationContainer.mozRequestFullScreen) {
            visualizationContainer.mozRequestFullScreen();
          } else if (visualizationContainer.msRequestFullscreen) {
            visualizationContainer.msRequestFullscreen();
          } else {
            visualizationContainer.classList.add("fullscreen");
            isFullscreen = true;
            fullscreenBtn.innerHTML = "⛶";
            fullscreenBtn.title = "Exit Fullscreen";
            setTimeout(() => resizeCanvas(), 100);
          }
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          } else {
            visualizationContainer.classList.remove("fullscreen");
            isFullscreen = false;
            fullscreenBtn.innerHTML = "⛶";
            fullscreenBtn.title = "Toggle Fullscreen";
            setTimeout(() => resizeCanvas(), 100);
          }
        }
      }

      function handleFullscreenChange() {
        const visualizationContainer = document.getElementById(
          "visualization-container"
        );
        const fullscreenBtn = document.getElementById("fullscreen-btn");

        const isCurrentlyFullscreen = !!(
          document.fullscreenElement ||
          document.webkitFullscreenElement ||
          document.mozFullScreenElement ||
          document.msFullscreenElement
        );

        if (isCurrentlyFullscreen && !isFullscreen) {
          isFullscreen = true;
          visualizationContainer.classList.add("fullscreen");
          fullscreenBtn.innerHTML = "⛷";
          fullscreenBtn.title = "Exit Fullscreen";
          setTimeout(() => resizeCanvas(), 100);
        } else if (!isCurrentlyFullscreen && isFullscreen) {
          isFullscreen = false;
          visualizationContainer.classList.remove("fullscreen");
          fullscreenBtn.innerHTML = "⛶";
          fullscreenBtn.title = "Toggle Fullscreen";
          setTimeout(() => resizeCanvas(), 100);
        }
      }

      // Event listeners
      function initEventListeners() {
        // Initialize chat functionality
        initChatEventListeners();

        // Mood boost modal event listeners
        const moodBoostYes = document.getElementById("mood-boost-yes");
        const moodBoostNo = document.getElementById("mood-boost-no");
        const moodBoostOverlay = document.getElementById("mood-boost-overlay");

        if (moodBoostYes) {
          moodBoostYes.addEventListener("click", handleMoodBoostYes);
        }

        if (moodBoostNo) {
          moodBoostNo.addEventListener("click", handleMoodBoostNo);
        }

        // Close modal when clicking outside (optional)
        if (moodBoostOverlay) {
          moodBoostOverlay.addEventListener("click", (e) => {
            if (e.target === e.currentTarget) {
              handleMoodBoostNo(); // Treat clicking outside as "no"
            }
          });
        }

        // Mood buttons
        document.querySelectorAll(".mood-btn").forEach((btn) => {
          btn.addEventListener("click", () => {
            const mood = btn.getAttribute("data-mood");
            selectMood(mood);
          });
        });

        // Text analysis
        document
          .getElementById("analyze-btn")
          .addEventListener("click", analyzeText);

        // Play/pause button
        document
          .getElementById("play-btn")
          .addEventListener("click", togglePlayPause);

        // Fullscreen button
        document
          .getElementById("fullscreen-btn")
          .addEventListener("click", toggleFullscreen);

        // Fullscreen change events
        document.addEventListener("fullscreenchange", handleFullscreenChange);
        document.addEventListener(
          "webkitfullscreenchange",
          handleFullscreenChange
        );
        document.addEventListener(
          "mozfullscreenchange",
          handleFullscreenChange
        );
        document.addEventListener("msfullscreenchange", handleFullscreenChange);

        // Progress bar click to seek
        document
          .querySelector(".progress-container")
          .addEventListener("click", (e) => {
            if (currentAudio && currentAudio.duration) {
              const rect = e.target.getBoundingClientRect();
              const clickX = e.clientX - rect.left;
              const percentage = clickX / rect.width;
              const newTime = percentage * currentAudio.duration;
              currentAudio.currentTime = newTime;
            }
          });

        // Volume control with mouse wheel on progress bar
        document
          .querySelector(".progress-container")
          .addEventListener("wheel", (e) => {
            e.preventDefault();
            if (currentAudio) {
              const volumeChange = e.deltaY > 0 ? -0.1 : 0.1;
              currentAudio.volume = Math.max(
                0,
                Math.min(1, currentAudio.volume + volumeChange)
              );

              // Visual feedback for volume change
              const progressContainer = e.target.closest(".progress-container");
              progressContainer.style.opacity = currentAudio.volume;
              setTimeout(() => {
                progressContainer.style.opacity = "1";
              }, 200);
            }
          });

        // Keyboard shortcuts
        document.addEventListener("keydown", (e) => {
          if (e.target.tagName === "TEXTAREA") return;

          switch (e.code) {
            case "Space":
              e.preventDefault();
              togglePlayPause();
              break;
            case "KeyF":
              e.preventDefault();
              toggleFullscreen();
              break;
            case "ArrowUp":
              e.preventDefault();
              if (currentAudio) {
                currentAudio.volume = Math.min(1, currentAudio.volume + 0.1);
              }
              break;
            case "ArrowDown":
              e.preventDefault();
              if (currentAudio) {
                currentAudio.volume = Math.max(0, currentAudio.volume - 0.1);
              }
              break;
            case "ArrowLeft":
              e.preventDefault();
              if (currentAudio) {
                currentAudio.currentTime = Math.max(
                  0,
                  currentAudio.currentTime - 10
                );
              }
              break;
            case "ArrowRight":
              e.preventDefault();
              if (currentAudio) {
                currentAudio.currentTime = Math.min(
                  currentAudio.duration || 0,
                  currentAudio.currentTime + 10
                );
              }
              break;
            case "Escape":
              // Close mood boost modal with Escape key
              if (
                document
                  .getElementById("mood-boost-overlay")
                  .classList.contains("show")
              ) {
                e.preventDefault();
                handleMoodBoostNo();
              }
              break;
          }
        });

        // Window resize
        window.addEventListener("resize", () => {
          if (!isFullscreen) {
            resizeCanvas();
          }
        });

        // Enter key for text analysis
        document
          .getElementById("mood-text")
          .addEventListener("keypress", (e) => {
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              analyzeText();
            }
          });
      }

      // Initialize everything when page loads
      document.addEventListener("DOMContentLoaded", () => {
        initCanvas();
        initEventListeners();
        console.log("MoodTune with AI Agent initialized successfully!");

        // Simple test - add a debug message to confirm everything is loaded
        setTimeout(() => {
          console.log("Page fully loaded. You can now:");
          console.log(
            "1. Type 'testMoodBoostModal()' in console to test modal directly"
          );
          console.log(
            "2. Click Sad mood and wait 6 seconds for automatic popup"
          );
          console.log(
            "3. Check if modal HTML element exists:",
            !!document.getElementById("mood-boost-overlay")
          );
        }, 1000);
      });
    </script>
  </body>
</html>
